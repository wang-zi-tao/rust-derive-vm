#![feature(concat_idents)]
#![feature(more_qualified_paths)]
#[macro_use]
extern crate lexical_derive;
#[macro_use]
extern crate lexical;
#[macro_use]
extern crate failure;
#[macro_use]
extern crate runtime_derive;
#[macro_use]
extern crate derive_builder;
pub(crate) type TypeResourceImpl = memory_mmmu::RegistedType;
mod lua_lexical {
    use failure::Fallible;
    use smallstr::SmallString;
    use smallvec::SmallVec;
    use std::{iter::{Iterator, Peekable}, str::{from_utf8, Chars}};
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    enum LitStringPrefix {
        /// '\''
        Apostrophe,
        /// '"'
        DoubleQuotes,
        /// '[['
        LongBracket(usize),
    }
    impl LitStringPrefix {
        pub fn match_end(&self, iter: &mut Peekable<Chars>, c: char) -> bool {
            match self {
                Self::Apostrophe => {
                    if iter.peek() == Some(&'\'') {
                        iter.next().unwrap();
                        true
                    } else {
                        false
                    }
                }
                Self::DoubleQuotes => {
                    if iter.peek() == Some(&'\"') {
                        iter.next().unwrap();
                        true
                    } else {
                        false
                    }
                }
                Self::LongBracket(l) => {
                    let iter_clone = iter.clone();
                    if iter_clone.next() != Some(']') {
                        return false;
                    }
                    for i in 0..*l {
                        if iter_clone.next() != Some('=') {
                            return false;
                        }
                    }
                    if iter_clone.next() != Some(']') {
                        return false;
                    }
                    *iter = iter_clone;
                    true
                }
            }
        }
    }
    fn parse_string(iter: &mut Peekable<Chars>) -> Option<String> {
        let lit = Vec::<u8>::new();
        let fsdaewrq;
        let prefix = match iter.next()? {
            '\'' => LitStringPrefix::Apostrophe,
            '"' => LitStringPrefix::DoubleQuotes,
            '[' => {
                let mut level = 0;
                loop {
                    match iter.next()? {
                        '[' => break,
                        '=' => {
                            level += 1;
                        }
                        _ => return None,
                    }
                }
                LitStringPrefix::LongBracket(level)
            }
            _ => return None,
        };
        while let Some(c) = iter.next() {
            match c {
                '\'' | '\"' | ']' => {
                    if prefix.match_end(iter, c) {
                        return String::from_utf8(lit).ok();
                    }
                }
                '\n' => {
                    if prefix == LitStringPrefix::Apostrophe || prefix == LitStringPrefix::DoubleQuotes {
                        return None;
                    } else {
                        let buffer = SmallString::<[u8; 8]>::new();
                        buffer.push(c);
                        lit.extend_from_slice(buffer.as_bytes());
                    }
                }
                '\\' => {
                    let c1: &[u8] = match iter.next()? {
                        '\\' => &[b'\\'],
                        'a' => &[b'\x07'],
                        'b' => &[b'\x08'],
                        'f' => &[b'\x0c'],
                        'n' => &[b'\n'],
                        'r' => &[b'\r'],
                        't' => &[b'\t'],
                        'v' => &[b'\x0b'],
                        '\"' => &[b'\"'],
                        '\'' => &[b'\''],
                        'z' => &[b'1'],
                        'x' => {
                            let c2 = iter.next()?;
                            let c3 = iter.next()?;
                            let n2 = match c2 {
                                '0'..='9' => c2 as u8 - b'0',
                                'a'..='f' => c2 as u8 - b'a' + 10,
                                'A'..='F' => c2 as u8 - b'A' + 10,
                                _ => return None,
                            };
                            let n3 = match c3 {
                                '0'..='9' => c3 as u8 - b'0',
                                'a'..='f' => c3 as u8 - b'a' + 10,
                                'A'..='F' => c3 as u8 - b'A' + 10,
                                _ => return None,
                            };
                            &[n2 << 4 | n3]
                        }
                        'u' => {
                            let buffer = SmallVec::<[u8; 8]>::new();
                            loop {
                                let mut char_buffer = [0u8; 8];
                                buffer.extend_from_slice(iter.next()?.encode_utf8(&mut char_buffer).as_bytes());
                                if let Ok(r) = from_utf8(&*buffer) {
                                    break;
                                }
                            }
                            &buffer
                        }
                        '0'..='9' => {
                            let c2 = iter.next()?;
                            let c3 = iter.next()?;
                            if !matches!(c2, '0'..='9') || !matches!(c3, '0'..='9') {
                                return None;
                            }
                            &[((c as u8 - b'0') << 6) | ((c2 as u8 - b'0') << 3) | (c3 as u8 - b'0')]
                        }
                        _ => return None,
                    };
                }
            }
        }
        None
    }
    #[derive(Debug, PartialEq)]
    #[lexical(["and","break","do","else","elseif","end","false","for","function","if","in","local","nil","not","or","repeat","return","then","true","until","while","goto"],["=",",",";",".",":","::","(",")","[","]","{","}","+","-","*","/","%","^","<<",">>","==",">","<",">=","<=","..","...","#","|","&","~"])]
    pub enum LuaLexical {
        #[lexical(regex = r"\d+")]
        Number(usize),
        #[lexical(regex = r"\p{L}+")]
        Name(String),
        #[lexical(regex = r#""\p{L}+""#)]
        String(String),
        #[lexical(ignore, regex = r#"--[^\n]*\n"#)]
        SingleLineAnnotation,
        #[lexical(ignore, regex = r#"--\[\[[*--]]\n"#)]
        MultiLineAnnotation,
        #[lexical(string = "~=")]
        NotEqual,
    }
}
struct LuaModule {}
struct LuaVM {}
pub mod mem {
    use crate::{builder::LuaContext, TypeResourceImpl};
    use b::GetLength;
    use failure::Fallible;
    use jvm_core::{make_reference, MoveIntoObject, Native, ObjectRef, Pointer, Reference, Resource, TypeDeclaration, TypeResource, UnsizedArray};
    use lexical::_lazy_static::lazy_static;
    use memory_mmmu::RegistedType;
    use runtime::instructions::bootstrap as b;
    use runtime_extra::{self as e, instructions::*, ty::*};
    use std::{alloc::Layout, cell::RefCell, collections::{HashMap, HashSet}, hash::Hash, rc::Rc, sync::Arc};
    use util::PooledStr;
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct LuaState {
        string_meta_functions: LuaMetaFunctionsReference,
        global: LuaTableReference,
        gc_mark: Bool,
    }
    make_reference!(LuaStateReference, LuaState, TypeResourceImpl);
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct LuaMetaFunctions {
        pub valid: Bool,
        pub meta_table: LuaTableReference,
        pub parent: NullableOption<LuaMetaFunctionsReference>,
        pub sub_metatable: Native<Vec<LuaMetaFunctionsReference>>,
        pub add: LuaValue,
        pub sub: LuaValue,
        pub mul: LuaValue,
        pub div: LuaValue,
        pub mod_: LuaValue,
        pub pow: LuaValue,
        pub unm: LuaValue,
        pub idiv: LuaValue,
        pub band: LuaValue,
        pub bor: LuaValue,
        pub bxor: LuaValue,
        pub bnot: LuaValue,
        pub shl: LuaValue,
        pub shr: LuaValue,
        pub concat: LuaValue,
        pub len: LuaValue,
        pub eq: LuaValue,
        pub lt: LuaValue,
        pub le: LuaValue,
        pub index: LuaValue,
        pub newindex: LuaValue,
        pub call: LuaValue,
        pub metadata: LuaValue,
        pub gc: LuaValue,
        pub mode: LuaValue,
        pub name: LuaValue,
        pub tostring: LuaValue,
        pub pairs: LuaValue,
    }
    make_reference!(LuaMetaFunctionsReference, LuaMetaFunctions, TypeResourceImpl);
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub enum Lifetime {
        Live,
        Dead,
    }
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct LuaString {
        lua_state: LuaStateReference,
        pooled: Native<Option<PooledStr>>,
        #[make_type(unsized)]
        data: UnsizedArray<U8>,
    }
    make_reference!(LuaStringReference, LuaString, TypeResourceImpl);
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct LuaFunction {
        resource: Native<ObjectRef>,
    }
    make_reference!(LuaFunctionReference, LuaFunction, TypeResourceImpl);
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct LuaClosure {
        function: LuaFunction,
        variables: Pointer<UnsizedArray<Pointer<LuaValue>>>,
        up_value: NullableOption<LuaUpValueReference>,
    }
    make_reference!(LuaClosureReference, LuaClosure, TypeResourceImpl);
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct LuaUpValue {
        #[make_type(unsized)]
        variables: UnsizedArray<LuaValue>,
    }
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub enum LuaField {
        String(Native<PooledStr>),
        Value(LuaValue),
    }
    impl Hash for LuaFieldImpl {
        fn hash<H: std::hash::Hasher>(&self, state: &mut H) { self.0.hash(state) }
    }
    impl PartialEq for LuaFieldImpl {
        fn eq(&self, other: &Self) -> bool { self.0.eq(&other.0) }
    }
    impl Eq for LuaFieldImpl {}
    make_reference!(LuaUpValueReference, LuaUpValue, TypeResourceImpl);
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct LuaSlotMetadata {
        slot: Usize,
    }
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct LuaShape {
        fields: Native<HashMap<LuaFieldImpl, LuaSlotMetadataImpl>>,
        meta_functions: NullableOption<LuaMetaFunctionsReference>,
        as_meta_table: NullableOption<LuaMetaFunctionsReference>,
        index_table: NullableOption<LuaTableReference>,
        max_int_index: U64,
        is_index_table: Bool,
        is_owned: Bool,
        action_of_field: Native<HashMap<PooledStr, (LuaShapeReference, usize)>>,
        action_of_metatable: Native<HashMap<LuaTableReference, LuaShapeReference>>,
    }
    make_reference!(LuaShapeReference, LuaShape, TypeResourceImpl);
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct LuaTable {
        shape: LuaShapeReference,
        slow_fields: NullablePointer<UnsizedArray<LuaValue>>,
        #[make_type(unsized)]
        fast_fields: UnsizedArray<LuaValue>,
    }
    make_reference!(LuaTableReference, LuaTable, TypeResourceImpl);
    pub type I64Reference = Reference<I64, TypeResourceImpl>;
    pub type F64Reference = Reference<F64, TypeResourceImpl>;
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction,tag_mask=[0..4])]
    pub enum LuaValue {
        #[make_type(mask=[4..64])]
        Integer(I64),
        #[make_type(mask=[4..64])]
        BigInt(I64Reference),
        #[make_type(mask=[4..64])]
        Float(I64),
        #[make_type(mask=[4..64])]
        BigFloat(F64Reference),
        #[make_type(mask=[4..64])]
        Boolean(Bool),
        #[make_type(mask=[4..64])]
        String(LuaStringReference),
        #[make_type(mask=[4..64])]
        Nil,
        #[make_type(mask=[4..64])]
        Table(LuaTableReference),
        #[make_type(mask=[4..64])]
        Function(LuaFunctionReference),
        #[make_type(mask=[4..64])]
        Closure(LuaClosureReference),
    }
    pub type LuaFunctionType = fn(state: LuaStateImpl, args: &[LuaValueImpl]) -> Box<[LuaValueImpl]>;
    pub type LuaClosureType =
        fn(state: LuaStateImpl, closure: LuaClosureReference, args: &[LuaValueImpl]) -> Box<[LuaValueImpl]>;
    impl LuaState {
        pub(crate) fn new_ctx(&self, token: ghost_cell::GhostToken) -> LuaContext { LuaContext::new(token) }
    }
}
pub mod instruction {
    use super::mem::*;
    use jvm_core::{FunctionType, Native, Pointer, Reference, Type, TypeDeclaration, UnsizedArray};
    use runtime::instructions::{bootstrap::{self as b, GetLength, GoToState, Read, SetState, Write}, Instruction};
    use runtime_extra::{self as e, instructions::*, ty::*};
    use std::{cell::RefCell, collections::HashMap, marker::PhantomData, rc::Rc};
    use util::{inline_const, CowArc, CowSlice, PooledStr};
    make_instruction! { ConstNil->fn()->(o:LuaValue){ entry:{ return lua_value::EncodeNil(); }} }
    make_instruction! { ConstTrue->fn()->(o:LuaValue){ entry:{ return lua_value::EncodeBoolean(true); }} }
    make_instruction! { ConstFalse->fn()->(o:LuaValue){ entry:{ return lua_value::EncodeBoolean(true); }} }
    make_instruction! { ConstZero->fn()->(o:I64){ entry:{ %o=0; }} }
    make_instruction! { ConstOne->fn()->(o:I64){ entry:{ %o=1; }} }
    make_instruction! { ConstM1->fn()->(o:I64){ entry:{ %o=-1; }} }
    make_instruction! { ToBool->fn(v:LuaValue)->(o:Bool){
        entry:{ if lua_value::IsBoolean(%v) %is_bool %not_bool; },
        not_bool:{ if lua_value::IsNil(%v) %is_nil %other; },
        is_nil:{ %o=false; },
        is_bool:{ %o=lua_value::DecodeBooleanUnchecked(%v); },
        other:{ %o=true; }
    } }
    make_instruction! { LogicalOr->fn(lhs:LuaValue,rhs:LuaValue)->(o:LuaValue){
        entry:{ if ToBool(%lhs) %true %false; },
        true:{ %o = %lsh; },
        false:{ %o = %rhs; },
    } }
    make_instruction! { LogicalNot->fn(v:LuaValue)->(o:LuaValue){
        entry:{ %o = lua_value::EncodeBoolean(BoolNot(ToBool(%v))); },
    } }
    make_instruction! {
        CallFunction->fn(callable:LuaValue)->(){
            entry:{ if lua_value::IsFunction(%callable) %is_function %not_function; },
            is_function:{e::TODO();},
            not_function:{ if lua_value::IsClosure(%callable) %is_closure %not_closure; },
            is_closure:{e::TODO();},
            not_closure:{ if lua_value::IsFunction(%callable) %is_object %other; },
            is_object:{e::TODO();},
            other:{ThrowError();},
        }
    }
    make_instruction! {IsFunction->fn(i:LuaValue)->(o:Bool){
    }}
    make_instruction! {
        FloatToInt->fn(f:F64)->(i:I64){ entry:{
            e::TODO();
        }}
    }
    make_instruction! {
        ThrowError->fn()->(){ entry:{
            e::TODO();
        }}
    }
    pub type OptionLuaMetaFunctionsRef = NullablePointer<LuaMetaFunctions>;
    #[derive(Instruction)]
    #[instruction(GetMetaValue->fn(v:LuaValue)->(o:OptionLuaMetaFunctionsRef){
            entry:{ if lua_value::IsTable(%v) %table %not_table; },
            table:{ return ReadMetaFunction(lua_shape::ReadMetaFunctions(lua_table::ReadShape(lua_value::DecodeTableUnchecked(%v)))); },
            not_table:{ if lua_value::IsString(%v) %string %not_string; },
            string:{ return ReadMetaFunction(lua_state::ReadStringMetaFunctions(lua_string::ReadLuaState(lua_value::DecodeStringUnchecked(%v)))); },
            not_string:{ return lua_value::EncodeNil(); },
    })]
    struct GetMetaValue<ReadMetaFunction: Instruction>(PhantomData<ReadMetaFunction>);
    make_instruction! { I64ToValue->fn(i:I64)->(v:LuaValue){
      entry:{
        %shift3_symbol=e::I64Shr(%i,3);//i>>3
        %tag_bit=e::I64Xor(%shift3_symbol,%i);//(i>>3)^i
        %masked_tag_bit=e::U64Shr(%tag_bit,60);//((i>>3)^i)>>>60 = (i>>63 & 7)^(i>>>60)
        %is_small=e::I64Eq(%masked_tag_bit,0);// i>>>60==0 | i>>>60==7
        if %is_small %small %big;
      },
      small:{ %v=lua_value::EncodeInteger(%i); },
      big:{
        %heap_object=b::AllocSized<I64::TYPE>();
        b::Store(%heap_object,%i);
        %object_ref=lua_value::EncodeBigInt(%heap_object);
        %v=lua_value::EncodeBigInt(%object_ref);
      },
    } }
    make_instruction! { GetIntegerValue->fn(value:LuaValue)->(int:I64){
        entry:{ if lua_value::IsInteger(%value) %small %large; },
        small:{ %int = lua_value::DecodeIntegerUnchecked(%value); },
        large:{ %itn = b::Read<I64::TYPE>(lua_value::DecodeBigIntUnchecked(%value)); }
    } }
    make_instruction! {
        F64ToValue->fn(f:F64)->(v:LuaValue){
          entry:{
            %i = e::F64AsI64(%f);
            %shift3_symbol=e::I64Shr(%i,3);//i>>5
            %tag_bit=e::I64Xor(%shift3_symbol,%i);//(i>>5)^i
            %masked_tag_bit=e::U64Shr(%tag_bit,58);//((i>>5)^i)>>>58 = (i>>63 & 31)^(i>>>58)
            %cleared_masked_tag_bit=e::I64And(%masked_tag_bit,15);
            %is_small=e::I64Eq(%masked_tag_bit,0);// i>>>60==0 | i>>>60==7
            if %is_small %small %big;
          },
          small:{
            %f_shift62 = e::U64Shr(%i,62);
            %f_left_shift6 = e::I64Shl(%i,6);
            %f_symbol = e::U64Shr(%i,6);
            %f_mask = e::I64Shl(%f_shift62,58);
            %f_compose = e::I64Or(%f_mask,%f_symbol);
            %v=lua_value::EncodeFloat(e::I64AsF64(%f_compose));
          },
          big:{
            %heap_object=b::AllocSized<F64::TYPE>();
            b::Store(%heap_object,%i);
            %object_ref=lua_value::EncodeBigInt(%heap_object);
            %v=lua_value::EncodeBigFloat(%object_ref);
          },
        }
    }
    make_instruction! {IsInteger->fn(i:LuaValue)->(o:Bool){entry:{
        %o=UsizeLt(lua_value::GetTag(%i),2);
    }}}
    make_instruction! {IsFloat->fn(i:LuaValue)->(o:Bool){entry:{
        %o=UsizeLt(UsizeSub(lua_value::GetTag(%i),2),2);
    }}}
    type GetMetaValueCall = GetMetaValue<lua_meta_functions::ReadCall>;
    make_instruction! { GetFloatValue->fn(value:LuaValue)->(float:F64){
        entry:{ if lua_value::IsFloat(%value) %small %large; },
        small:{ %int = lua_value::DecodeIntegerUnchecked(%value); },
        large:{ %itn = b::Read<I64::TYPE>(lua_value::DecodeBigFloatUnchecked(%value)); }
    } }
    make_instruction! {ToFloat->fn(i:LuaValue)->(o:F64){
        entry:{ if IsFloat(%i) %float %not_float; },
          float:{%o=GetFloatValue(%i);},
          not_float:{if IsInteger(%i) %integer %not_integer},
            integer:{%o=GetIntegerValue(%i);},
            not_integer:{ThrowError();},
    }}
    #[make_native_function(FPow)]
    pub extern "C" fn __vm_lua_lib_f64_pow(arg1: F64, arg2: F64) -> F64 { F64(f64::powf(arg1.0, arg2.0)) }
    #[make_native_function(FDivFloor)]
    pub extern "C" fn __vm_lua_lib_f64_div_floor(arg1: F64, arg2: F64) -> F64 { F64((arg1.0 / arg2.0).floor()) }

    type NoneLuaValueArray = e::nullable_pointer::EncodeNone<UnsizedArray<LuaValue>>;
    make_instruction! { BuildTable->fn<const shape:LuaShapeReference,const slots:Usize>()->(o:LuaValue){ entry:{
        %new_table=b::AllocUnsized<LuaTable::TYPE>(%slots);
        lua_table::WriteSlowFields(NoneLuaValueArray());
        lua_table::WriteShape(%shape);
        %o=lua_value::EncodeTable(%lua_table);
    }} }
    type GetMetaValueConcat = GetMetaValue<lua_meta_functions::ReadConcat>;
    make_instruction! {
        Concat->fn(i1:LuaValue,i2:LuaValue)->(v:LuaValue){
            entry:{ if BoolOr(lua_value::IsTable(%i1),lua_value::IsTable(%i)) %use_metatable %dont_use_meratable; },
              use_metatable:{
                  %i1_meta_function = GetMetaValueConcat(%i1);
                  if lua_value::IsNil(%i1_meta_function) %i1_has_no_meta_function %i1_has_meta_function; },
                i1_has_meta_function:{ %o=CallFunction(%i1_meta_function,%i1,%i2); },
                i1_has_no_meta_function:{
                    %i2_meta_function = GetMetaValueConcat(%lua_state,%i2);
                    if lua_value::IsNil(%i2_meta_function) %i2_has_no_meta_function %i2_has_meta_function; },
                i2_has_meta_function:{ %o=CallFunction(%i2_meta_function,%i1,%i2); },
              dont_use_meratable:{ %v=RawConcat(%i1,%i2); },
        }
    }
    make_instruction! {
        Length->fn(value:LuaValue)->(v:LuaValue){
            entry:{ if lua_value::IsString(%value) %string %not_string; },
            string:{ %v=I64ToValue(GetLength<U8::TYPE>(lua_string::LocateData(lua_value::DecodeStringUnchecked(%value)))); },
            not_string:{ if lua_value::IsTable(%value) %table %error; },
            table:{
                %meta_function=lua_meta_functions::ReadLen(lua_shape::ReadMetaFunctions(lua_table::ReadShape(lua_value::DecodeTableUnchecked(%v))));
                if lua_value::IsNil(%meta_function) %use_int_keys %use_meta_function;
            },
            use_meta_function:{%v=CallFunction(%meta_function,%value);},
            use_int_keys:{%v=lua_shape::ReadMaxIntIndex(lua_table::ReadShape(lua_value::DecodeTableUnchecked(%v)));},
            error:{ThrowError();}
        }
    }
    make_instruction! {
        NewClosure->fn(value:LuaValue)->(v:LuaValue){
            entry:{
                e::TODO();
            },
        }
    }
    make_instruction! {
        IfBranch->fn<block then,block else>(i:LuaValue){ entry:{
            IfBranch<%then,%else>(ToBool(%i));
        }}
    }
    make_instruction! {
        IForLoopJump->fn<block loop,block break>(end:I64,state:I64)->(int_state:I64){ entry:{
            if I64Le(%state,%end) %loop %break;
        }}
    }
    make_instruction! {
        FForLoopJump->fn<block loop,block break>(end:F64,state:F64)->(int_state:I64){ entry:{
            if F64Le(%state,%end) %loop %break;
        }}
    }
    make_instruction! {
        ForLoopJump->fn(is_float:Bool,int_state:I64,float_state:F64)->(is_float:Bool,int_state:I64,float_state:F64,o:LuaValue){
            entry:{
                e::TODO();
            },
        }
    }
    make_instruction! {
        F64ToI64->fn(f:F64)->(o:I64){
            entry:{
                e::TODO();
            },
        }
    }
    use super::mem::{LuaMetaFunctionsTrait, LuaValueTrait};
    #[derive(Instruction)]
    #[instruction(
        UniqueInstruction->{(i1:LuaValue)->(o:LuaValue){
            None:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    if I32Le(%i1_tag,4) %number %not_number; },
                  number:{ if I32Le(%i1_tag,2) %integer %not_integer; },
                    integer:{
                        %i1_integer_value=GetIntegerValue(%i1);
                        SetState<%Integer>();
                        %o=IntegerInstruction(%i1_integer_value); },
                    not_integer:{
                        %i1_float_value=GetFloatValue(%i1);
                        SetState<%Float>();
                        %o=FloatInstruction(%i1_float_value); },
                  not_number:{
                      %i1_meta_function = GetMetaFunction(%i1);
                      if lua_value::IsNil(%i1_meta_function) %i1_has_no_meta_function %i1_has_meta_function; },
                    i1_has_meta_function:{
                        SetState<%UseMetaMethodOfI1>();
                        %o=CallFunction(%i1_meta_function,%i1); },
                    i1_has_no_meta_function:{ ThrowError(); },
            },
            Integer:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    if I32Less(%i1_tag,2) %integer %other; },
                integer:{
                    %i1_integer_value=GetIntegerValue(%i1);
                    %o=IntegerInstruction(%i1_integer_value); },
                other:{ return GoToState<%Init>(); },
            },
            Float:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    if UsizeLarge(2,UsizeSub(%i1_tag,2)) %integer %other; },
                float:{
                    %i1_float_value=GetFloatValue(%i1);
                    return FloatInstruction(%i1_float_value); },
                other:{ return GoToState<%Init>(); },
            },
            UseMetaMethodOfI1:{
                entry:{
                    %i1_meta_function = GetMetaFunction(%i1);
                    if lua_value::IsNil(%i1_meta_function) %other %i1_has_meta_function; },
                i1_has_meta_function:{
                    SetState<%UseMetaMethodOfI1>();
                    %o=CallFunction(%i1_meta_function,%i1); },
                other:{ SetState<%Init>(); },
            },
        }}
        )]
    struct UniqueInstruction<IntegerInstruction: Instruction, FloatInstruction: Instruction, GetMetaFunction: Instruction>(
        PhantomData<(IntegerInstruction, FloatInstruction, GetMetaFunction)>,
    );
    #[derive(Instruction)]
    #[instruction(
        BinaryInstruction->{(i1:LuaValue,i2:LuaValue)->(o:LuaValue){
            None:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    %i2_tag=lua_value::GetTag(%i2);
                    if I32Le(I32Or(%i1_tag,%i2_tag),4) %double_number %not_double_number; },
                double_number:{ if UsizeLe(UsizeOr(%i1_tag,%i2_tag),2) %double_integer %not_double_integer; },
                double_integer:{
                    %i1_integer_value=GetIntegerValue(%i1);
                    %i2_integer_value=GetIntegerValue(%i2);
                    SetState<%DoubleInteger>();
                    %o=IntegerInstruction(%i1_integer_value,%i2_integer_value); },
                not_double_integer:{
                    %i1_float_value=ToFloat(%i1);
                    %i2_float_value=ToFloat(%i2);
                    SetState<%DoubleFloat>();
                    %o=FloatInstruction(%i1_float_value,%i2_float_value); },
                not_double_number:{
                    %i1_meta_function = GetMetaFunction(%i1);
                    if lua_value::IsNil(%i1_meta_function) %i1_has_no_meta_function %i1_has_meta_function; },
                i1_has_meta_function:{
                    SetState<%UseMetaMethodOfI1>();
                    %o=CallFunction(%i1_meta_function,%i1,%i2); },
                i1_has_no_meta_function:{
                    %i2_meta_function = GetMetaFunction(%i2);
                    if lua_value::IsNil(%i2_meta_function) %i2_has_no_meta_function %i2_has_meta_function; },
                i2_has_meta_function:{
                    SetState<%UseMetaMethodOfI2>();
                    %o=CallFunction(%i2_meta_functions_ptr,%i1,%i2); },
                i2_has_no_meta_function:{ return ThrowError(); },
            },
            DoubleInteger:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    %i2_tag=lua_value::GetTag(%i2);
                    if I32Less(I32Or(%i1_tag,%i2_tag),2) %double_integer %other; },
                double_integer:{
                    %i1_integer_value=GetIntegerValue(%i1);
                    %i2_integer_value=GetIntegerValue(%i2);
                    %o=IntegerInstruction(%i1_integer_value,%i2_integer_value); },
                other:{ return GoToState<%Init>(); },
            },
            DoubleFloat:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    %i2_tag=lua_value::GetTag(%i2);
                    if UsizeLarge(2,UsizeSub(UsizeOr(%i1_tag,%i2_tag),2)) %double_integer %other; },
                double_float:{
                    %i1_float_value=GetFloatValue(%i1);
                    %i2_float_value=GetFloatValue(%i2);
                    return FloatInstruction(%i1_float_value,%i2_float_value); },
                other:{ return GoToState<%Init>(); },
            },
            UseMetaMethodOfI1:{
                entry:{
                    %i1_meta_function = GetMetaFunction(%i1);
                    if lua_value::IsNil(%i1_meta_function) %other %i1_has_meta_function; },
                i1_has_meta_function:{
                    SetState<%UseMetaMethodOfI1>();
                    %o=CallFunction(%i1_meta_function,%i1,%i2); },
                other:{ SetState<%Init>(); },
            },
            UseMetaMethodOfI2:{
                entry:{
                    %i1_meta_function = GetMetaFunction(%i1);
                    if lua_value::IsNil(%i1_meta_function) %other %i1_has_meta_function; },
                i1_has_meta_function:{
                    %i1_meta_functions_ptr=OptionLuaMetaFunctionsRef::DecodeSome(%i1_meta_function);
                    SetState<%UseMetaMethodOfI1>();
                    %meta_function = GetMetaFunction(%i1_meta_functions_ptr);
                    %o=CallFunction(%meta_function,%i1,%i2); },
                i1_has_no_meta_function:{
                    %i2_meta_function = GetMetaFunction(%i2);
                    if lua_value::IsNil(%i2_meta_function) %i2_has_no_meta_function %i2_has_meta_function; },
                i2_has_meta_function:{
                    SetState<%UseMetaMethodOfI2>();
                    %o=CallFunction(%i2_meta_function,%i1,%i2); },
                other:{ SetState<%Init>(); },
            },
        }}
        )]
    struct BinaryInstruction<IntegerInstruction: Instruction, FloatInstruction: Instruction, GetMetaFunction: Instruction>(
        PhantomData<(IntegerInstruction, FloatInstruction, GetMetaFunction)>,
    );
    #[derive(Instruction)]
    #[instruction(
        UniqueIntegerInstruction->{(i1:LuaValue,)->(o:LuaValue){
            None:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    if I32Le(%i1_tag,4) %number %not_number; },
                number:{
                    %i1_integer_value=GetIntegerValue(%i1);
                    SetState<%DoubleInteger>();
                    %o=IntegerInstruction(%i1_integer_value); },
                not_double_number:{
                    %i1_meta_function = GetMetaFunction(%i1);
                    if lua_value::IsNil(%i1_meta_function) %i1_has_no_meta_function %i1_has_meta_function; },
                i1_has_meta_function:{
                    SetState<%UseMetaMethodOfI1>();
                    %o=CallFunction(%i1_meta_function,%i1);
                },
                i1_has_no_meta_function:{ return ThrowError(); },
            },
            Integer:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    if I32Less(%i1_tag,4) %double_number %other; },
                number:{
                    %i1_integer_value=GetIntegerValue(%i1);
                    %o=IntegerInstruction(%i1_integer_value); },
                other:{ return GoToState<%Init>(); },
            },
            UseMetaMethodOfI1:{
                entry:{
                    %i1_meta_function = GetMetaFunction(%i1);
                    if lua_value::IsNil(%i1_meta_function) %other %i1_has_meta_function; },
                i1_has_meta_function:{
                    SetState<%UseMetaMethodOfI1>();
                    %o=CallFunction(%i1_meta_function,%i1); },
                other:{ SetState<%Init>(); },
            },
        }}
        )]
    struct UniqueIntegerInstruction<IntegerInstruction: Instruction, GetMetaFunction: Instruction>(
        PhantomData<(IntegerInstruction, GetMetaFunction)>,
    );
    #[derive(Instruction)]
    #[instruction(
        BinaryIntegerInstruction->{(i1:LuaValue,i2:LuaValue)->(o:LuaValue){
            None:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    %i2_tag=lua_value::GetTag(%i2);
                    if I32Le(I32Or(%i1_tag,%i2_tag),4) %double_number %not_double_number; },
                double_number:{
                    %i1_integer_value=GetIntegerValue(%i1);
                    %i2_integer_value=GetIntegerValue(%i2);
                    SetState<%DoubleInteger>();
                    %o=IntegerInstruction(%i1_integer_value,%i2_integer_value); },
                not_double_number:{
                    %i1_meta_function = GetMetaFunction(%i1);
                    if lua_value::IsNil(%i1_meta_function) %i1_has_no_meta_function %i1_has_meta_function; },
                i1_has_meta_function:{
                    SetState<%UseMetaMethodOfI1>();
                    %o=CallFunction(%i1_meta_function,%i1,%i2);
                },
                i1_has_no_meta_function:{
                    %i2_meta_function = GetMetaFunction(%i2);
                    if lua_value::IsNil(%i2_meta_function) %i2_has_no_meta_function %i2_has_meta_function; },
                i2_has_meta_function:{
                    SetState<%UseMetaMethodOfI2>();
                    %o=CallFunction(%i2_meta_function,%i1,%i2); },
                i2_has_no_meta_function:{ return ThrowError(); },
            },
            DoubleInteger:{
                entry:{
                    %i1_tag=lua_value::GetTag(%i1);
                    %i2_tag=lua_value::GetTag(%i2);
                    if I32Less(I32Or(%i1_tag,%i2_tag),4) %double_number %other; },
                double_number:{
                    %i1_integer_value=GetIntegerValue(%i1);
                    %i2_integer_value=GetIntegerValue(%i2);
                    %o=IntegerInstruction(%i1_integer_value,%i2_integer_value); },
                other:{ return GoToState<%Init>(); },
            },
            UseMetaMethodOfI1:{
                entry:{
                    %i1_meta_function = GetMetaFunction(%i1);
                    if lua_value::IsNil(%i1_meta_function) %other %i1_has_meta_function; },
                i1_has_meta_function:{
                    SetState<%UseMetaMethodOfI1>();
                    %o=CallFunction(%i1_meta_function,%i1,%i2); },
                other:{ SetState<%Init>(); },
            },
            UseMetaMethodOfI2:{
                entry:{
                    %i1_meta_function = GetMetaFunction(%i1);
                    if OptionLuaMetaFunctionsRef::IsSome(%i1_meta_function) %i1_has_meta_function %other; },
                i1_has_meta_function:{
                    SetState<%UseMetaMethodOfI1>();
                    %o=CallFunction(%i2_meta_function,%i1,%i2);
                },
                i1_has_no_meta_function:{
                    %i2_meta_function = GetMetaFunction(%i2);
                    if lua_value::IsNil(%i2_meta_function) %i2_has_no_meta_function %i2_has_meta_function; },
                i2_has_meta_function:{
                    SetState<%UseMetaMethodOfI2>();
                    %o=CallFunction(%i2_meta_function,%i1,%i2); },
                other:{ SetState<%Init>(); },
            },
        }}
        )]
    struct BinaryIntegerInstruction<IntegerInstruction: Instruction, GetMetaFunction: Instruction>(
        PhantomData<(IntegerInstruction, GetMetaFunction)>,
    );
    #[derive(Instruction)]
    #[instruction( WrapToInteger->fn(i1:I64,i2:I64)->(o:LuaValue){ entry:{
        %o = I64ToValue(I(%i1,%i2));
    } })]
    struct WrapBinaryInteger<I: Instruction>(PhantomData<I>);
    #[derive(Instruction)]
    #[instruction( WrapToFloat->fn(i1:F64,i2:F64)->(o:LuaValue){ entry:{
        %o = F64ToValue(I(%i1,%i2));
    } })]
    struct WrapBinaryFloat<I: Instruction>(PhantomData<I>);
    #[derive(Instruction)]
    #[instruction( WrapToInteger->fn(i1:I64)->(o:LuaValue){ entry:{
        %o = I64ToValue(I(%i1));
    } })]
    struct WrapInteger<I: Instruction>(PhantomData<I>);
    #[derive(Instruction)]
    #[instruction( WrapToFloat->fn(i1:F64)->(o:LuaValue){ entry:{
        %o = F64ToValue(I(%i1));
    } })]
    struct WrapFloat<I: Instruction>(PhantomData<I>);
    #[derive(Instruction)]
    #[instruction( WrapBinaryIntToBool->fn(i1:I64,i2:I64)->(o:LuaValue){ entry:{
        %o = lua_value::EncodeBoolean(I(%i1,%i2));
    } })]
    struct WrapBinaryIntToBool<I: Instruction>(PhantomData<I>);
    #[derive(Instruction)]
    #[instruction( WrapBinaryIntToReverseBool->fn(v1:LuaValue,v2:LuaValue)->(o:LuaValue){ entry:{
        %o = lua_value::EncodeBoolean(BoolNot(I(%v1,%v2)));
    } })]
    struct WrapBinaryToReverseBool<I: Instruction>(PhantomData<I>);
    #[derive(Instruction)]
    #[instruction( WrapBinaryIntToReverseBool->fn(v1:LuaValue,v2:LuaValue)->(o:LuaValue){ entry:{
        %o = lua_value::EncodeBoolean(I(%v2,%v1));
    } })]
    struct FlipBinaryValueToBool<I: Instruction>(PhantomData<I>);
    #[derive(Instruction)]
    #[instruction( WrapBinaryFloatToBool->fn(i1:F64,i2:F64)->(o:LuaValue){ entry:{
        %o = lua_value::EncodeBoolean(I(%i1,%i2));
    } })]
    struct WrapBinaryFloatToBool<I: Instruction>(PhantomData<I>);
    #[derive(Instruction)]
    #[instruction( WrapBinaryIntToFloat->fn(i1:I64,i2:I64)->(o:LuaValue){ entry:{
        %o = F64ToValue(I(I64ToF64(%i1),I64ToF64(%i2)));
    } })]
    struct WrapBinaryIntToFloat<I: Instruction>(PhantomData<I>);
    pub type Add = BinaryInstruction<
        WrapBinaryInteger<I64Add>,
        WrapBinaryFloat<F64Add>,
        GetMetaValue<lua_meta_functions::ReadAdd>,
    >;
    pub type Sub = BinaryInstruction<
        WrapBinaryInteger<I64Sub>,
        WrapBinaryFloat<F64Sub>,
        GetMetaValue<lua_meta_functions::ReadSub>,
    >;
    pub type Mul = BinaryInstruction<
        WrapBinaryInteger<I64Mul>,
        WrapBinaryFloat<F64Mul>,
        GetMetaValue<lua_meta_functions::ReadMul>,
    >;
    pub type Pow =
        BinaryInstruction<WrapBinaryIntToFloat<FPow>, WrapBinaryFloat<FPow>, GetMetaValue<lua_meta_functions::ReadPow>>;
    pub type IDiv = WrapBinaryIntToFloat<F64Div>;
    pub type Div = BinaryInstruction<
        WrapBinaryIntToFloat<F64Div>,
        WrapBinaryFloat<F64Div>,
        GetMetaValue<lua_meta_functions::ReadDiv>,
    >;
    pub type Equal = BinaryInstruction<
        WrapBinaryIntToBool<I64Eq>,
        WrapBinaryFloatToBool<F64Eq>,
        GetMetaValue<lua_meta_functions::ReadEq>,
    >;
    pub type LessOrEqual = BinaryInstruction<
        WrapBinaryIntToBool<I64Le>,
        WrapBinaryFloatToBool<F64Le>,
        GetMetaValue<lua_meta_functions::ReadLe>,
    >;
    pub type Less = BinaryInstruction<
        WrapBinaryIntToBool<I64Lt>,
        WrapBinaryFloatToBool<F64Lt>,
        GetMetaValue<lua_meta_functions::ReadLt>,
    >;
    pub type NotEqual = WrapBinaryToReverseBool<Equal>;
    pub type Large = FlipBinaryValueToBool<LessOrEqual>;
    pub type LargeOrEqual = FlipBinaryValueToBool<Less>;
    pub type Neg = UniqueInstruction<WrapInteger<I64Neg>, WrapFloat<F64Neg>, GetMetaValue<lua_meta_functions::ReadUnm>>;
    pub type DivFloor = BinaryIntegerInstruction<I64Div, GetMetaValue<lua_meta_functions::ReadIdiv>>;
    pub type Rem = BinaryInstruction<
        WrapBinaryInteger<I64Rem>,
        WrapBinaryFloat<F64Rem>,
        GetMetaValue<lua_meta_functions::ReadMod>,
    >;
    pub type BitAnd = BinaryIntegerInstruction<WrapBinaryInteger<I64And>, GetMetaValue<lua_meta_functions::ReadBand>>;
    pub type BitOr = BinaryIntegerInstruction<WrapBinaryInteger<I64Or>, GetMetaValue<lua_meta_functions::ReadBor>>;
    pub type BitXor = BinaryIntegerInstruction<WrapBinaryInteger<I64Xor>, GetMetaValue<lua_meta_functions::ReadBxor>>;
    pub type BitNot = UniqueIntegerInstruction<WrapInteger<I64Not>, GetMetaValue<lua_meta_functions::ReadBnot>>;
    pub type LeftShift = BinaryIntegerInstruction<WrapBinaryInteger<I64Shl>, GetMetaValue<lua_meta_functions::ReadShl>>;
    pub type RightShift =
        BinaryIntegerInstruction<WrapBinaryInteger<I64Shr>, GetMetaValue<lua_meta_functions::ReadShr>>;
    pub type MoveI64 = Move<I64>;
    pub type MoveF64 = Move<F64>;
    pub type MoveValue = Move<LuaValue>;
    #[derive(TypeDeclaration)]
    #[make_type(make_instruction)]
    pub struct InlineCacheLine {
        shape: NullableOption<LuaShapeReference>,
        key: NullableOption<LuaTableReference>,
        slot: U16,
    }
    #[make_native_function(GetSlot)]
    pub unsafe extern "C" fn __vm_lua_lib_get_slot(shape: Pointer<LuaShape>, key: Pointer<LuaField>) -> Usize {
        shape.as_ref().ref_fields().get(key).unwrap_or(Usize(usize::MAX))
    }
    type ReadFieldElement = ReadElement<LuaValue, Pointer<UnsizedArray<LuaValue>>>;
    make_instruction! {
        GetElement->fn(table:LuaValue,key:LuaValue)->(value:LuaValue){
          entry:{branch %loop;},
          loop:{
              phi %table={%entry=>%table,%use_index_table=>%index_table};
              %shape=lua_table::ReadShape(%table);
              %slot=GetSlot(%shape,%key);
              if I64Less(%shape,0) %not_found %found; },
            found:{ %value=Read<LuaValue::TYPE>(LocateSlot(%table,%slot)); },
            not_found:{
                %index=lua_meta_functions::ReadIndex(lua_shape::ReadMetaFunctions(%shape));
                if lua_value::IsTable(%index) %use_index_table %not_index_table; },
              not_index_table:{if lua_value::IsNil(%table) %use_nil %index_callable;},
              index_callable:{ Call(%new_index,%table,%key); },
            use_nil:{%value=lua_value::EncodeNil();},
          use_index_table:{
              %index_table=lua_value::DecodeTableUnchecked(%index);
              branch %loop;
          },
        }
    }
    type GetMetaValueNewIndex = GetMetaValue<lua_meta_functions::ReadNewindex>;
    make_instruction! {
        SetElement->fn<mut cache:InlineCacheLine>(table:LuaValue,key:LuaValue,value:LuaValue){
          entry:{branch %loop;},
          loop:{
              phi %table={%entry=>%table,%new_index_table=>%new_index_table};
              %shape=lua_table::ReadShape(%table);
              %slot=GetSlot(%shape,%key);
              if I64Less(%shape,0) %not_found %found; },
            found:{
                inline_cache_line::WriteKey(%key);
                inline_cache_line::WriteShape(%shape);
                inline_cache_line::WriteSlot(%slot);
                Write<LuaValue::TYPE>(LocateSlot(%table,%slot),%value); },
            not_found:{
                %new_index=lua_meta_functions::ReadNewindex(lua_shape::ReadMetaFunctions(%shape));
                if lua_value::IsNil(%new_index) %add_slot %use_new_index; },
              use_new_index:{ if lua_value::IsTable(%new_index) %use_new_index_table %use_new_index_function; },
              use_new_index_function:{ Call(%new_index,%table,%key,%value); },
              use_new_index_table:{
                  %new_index_table=lua_value::DecodeTableUnchecked(%new_index);
                  branch %loop; },
              add_slot:{ if lua_shape::ReadIsOwned(%shape) %expend %other_shape; },
                entend:{
                  %fields=lua_shape::LocateFields(%shape);
                  %slot=FieldsCount(%fields);
                  %slot_metadata=lua_slot_metadata::New(%slot);
                  InsertField(%fields,%key,%slot_metadata);
                  Write<LuaValue::TYPE>(LocateNewSlot(%table,%slot),%value); },
                other_slot:{
                    %goto_action=ShapeAction(%shape,%key);
                    if NullableShapeIsSome(%goto_shape) %goto_shape %clone_shape; },
                  goto_shape:{
                      lua_table::WriteShape(%table,NullableDecodeSome(%goto_shape));
                      Write<LuaValue::TYPE>(LocateNewSlot(%table,%slot),%value); },
                  clone_shape:{
                      %new_shape=lua_shape::Clone(%new_shape);
                      lua_table::WriteShape(%table,%new_shape);
                      %fields=lua_shape::LocateFields(%new_shape);
                      %slot=FieldsCount(%fields);
                      %slot_metadata=lua_slot_metadata::New(%slot);
                      InsertField(%fields,%key,%slot_metadata);
                      Write<LuaValue::TYPE>(LocateNewSlot(%table,%slot),%value); },
        }
    }
    make_instruction! {
        LocateSlot->fn(object:Pointer<LuaTable>,slot:Usize)->(o:Pointer<LuaValue>){
            entry:{
                %fast_len = GetLength(lua_table::LocateFastFields(%object));
                if UsizeLarge(%fast_len,%slot) %fast %slow;
            },
            fast:{ %o = LocateElement<LuaValue::TYPE>(lua_table::LocateFastFields(%object),%slot); },
            slow:{ %o = LocateElement<LuaValue::TYPE>(lua_table::ReadSlowFields(%object),UsizeSub(%slot,%fast_len)); }
        }
    }
    make_instruction! {
        GetGlobalField->{<const field:LuaField,mut cache:Usize>(table:LuaTable)->(o:LuaValue){
            Init:{
                entry:{
                    %shape=lua_table::ReadShape(%table);
                    %number_of_continuous_miss = U8Add(%number_of_continuous_miss,1);
                    %result = GetShapeField<%cache>(%shape,%field);
                    SetState<%Cached>(); %o = Read<LuaValue::TYPE>(LocateSlot(%table,%slot)); },
            },
            Cached:{ entry:{ return ReadSlot(%table,%cache);}},
        }}
    }
    make_instruction! {
        GetField->{<const field:LuaField,mut cache:InlineCacheLine,mut number_of_continuous_miss:U8>(object:LuaValue)->(o:LuaValue){
            Init:{
                entry:{ if lua_value::IsTable(%object) %is_object %is_not_object; },
                is_object:{
                    %shape=lua_table::ReadShape(%object);
                    %number_of_continuous_miss = U8Add(%number_of_continuous_miss,1);
                    %result = GetShapeField<%cache>(%shape,%field);
                    if U8Lt(%number_of_continuous_miss,8) %do_not_use_cache %set_cache;
                },
                do_not_use_cache:{ %o = Read<LuaValue::TYPE>(LocateSlot(%object,%slot)); },
                set_cache:{ SetState<%Cached>(); %o = Read<LuaValue::TYPE>(LocateSlot(%object,%slot)); },
                is_not_object:{ ThrowError(); },
            },
            NoCache:{
                entry:{ if lua_value::IsTable(%object) %is_object %is_not_object; },
                is_object:{
                    %shape=lua_table::ReadShape(%object);
                    %number_of_continuous_miss = U8Add(%number_of_continuous_miss,1);
                    %result = GetShapeField<%cache>(%shape,%field);
                    %cache_key = %shape;
                    %cache_value = %slot;
                    SetState<%Cached>();
                    return %result;
                },
                is_not_object:{ ThrowError(); },
            },
            Cached:{
                entry:{ if lua_value::IsTable(%object) %is_object %is_not_object; },
                is_object:{
                    %shape=lua_table::ReadShape(%object);
                    if ShapePointerEq(%shape,%cache_key) %hit %miss; },
                    hit:{
                        %number_of_continuous_miss = 0;
                        return RawGetField(%object,%cache_value); },
                    miss:{
                        %number_of_continuous_miss = U8Add(%number_of_continuous_miss,1);
                        %slot = GetShapeField(%shape,%field);
                        if U8Lt(%number_of_continuous_miss,8) %clean_cache %update_cache; },
                clean_cache:{
                    return RawGetField(%object,%slot);
                    SetState<%NoCached>(); },
                update_cache:{
                    %cache_key = %shape;
                    %cache_value = %slot;
                    return RawGetField(%object,%slot); },
                is_not_object:{ ThrowError(); },
            },
        }}
    }
}
pub mod ir {
    use super::{instruction as i, mem::*};
    use jvm_core::{Native, Reference, TypeDeclaration, UnsizedArray};
    use runtime::instructions::{bootstrap as b, Instruction};
    use runtime_extra::{self as e, instructions::*, ty::*};
    use std::{cell::RefCell, collections::HashMap, rc::Rc};
    use util::PooledStr;
    make_instruction_set! {
      LuaInstructionSet=[
        Nop->b::Nop,
        MoveI64->i::MoveI64,MoveF64->i::MoveF64,MoveValue->i::MoveValue,
        ConstM1->i::ConstM1,ConstZero->i::ConstZero,ConstOne->i::ConstOne,ConstI64->e::I64Const,
        ConstNil->i::ConstNil,ConstTrue->i::ConstTrue,ConstFalse->i::ConstFalse,
        GetField->i::GetField, SetField->i::SetField,
        GetElement->i::GetElement, SetElement->i::SetElement,
        I64ToValue->i::I64ToValue, F64ToValue->i::F64ToValue,
        I64ToF64->e::I64ToF64, F64ToI64->i::F64ToI64,
        IAdd->e::I64Add, FAdd->e::F64Add, Add->i::Add,
        ISub->e::I64Sub, FSub->e::F64Sub, Sub->i::Sub,
        IMul->e::I64Mul, FMul->e::F64Mul, Mul->i::Mul,
        FPow->i::FPow, Pow->i::Pow,
        IDiv->i::IDiv, FDiv->e::F64Div, Div->i::Div,
        IDivFloor->e::I64Div, FDivFloor->i::FDivFloor, DivFloor->i::DivFloor,
        IRem->e::I64Rem, FRem->e::F64Rem, Rem->i::Rem,
        IBitXor->e::I64Xor, BitXor->i::BitXor,
        IBitAnd->e::I64And, BitAnd->i::BitAnd,
        IBitOr->e::I64Or, BitOr->i::BitOr,
        IBitNot->e::I64Not, BitNot->i::BitNot,
        INeg->e::I64Neg, FNeg->e::F64Neg, Neg->i::Neg,
        LogicalNot->i::LogicalNot,
        ILeftShift->e::I64LeftShift, LeftShift->i::LeftShift,
        IRightShift->e::I64RightShift, RightShift->i::RightShift,
        ILess->e::I64Less, FLess->e::F64Less, Less->i::Less,
        ILessOrEqual->e::I64LessOrEqual, FLessOrEqual->e::F64LessOrEqual, LessOrEqual->i::LessOrEqual,
        IEqual->e::I64Equal, FEqual->e::F64Equal, Equal->i::Equal,
        ILarge->e::I64Large, FLarge->e::F64Large, Large->i::Large,
        ILargeOrEqual->e::I64LargeOrEqual, FLargeOrEqual->e::F64LargeOrEqual, LargeOrEqual->i::LargeOrEqual,
        INotEqual->e::I64NotEqual, FNotEqual->e::F64NotEqual, NotEqual->i::NotEqual,
        Concat->i::Concat,
        Length->i::Length,
        Call->i::Call,
        Goto->e::Goto,
        BuildObject->i::BuildObject,
        NewClosure->i::NewClosure,
        ForLoopJump->i::ForLoopJump,
        IfBranch->i::IfBranch,
      ]
    }
}
pub mod builder {
    use super::ir::I64ToF64;
    use super::{ir, ir::*, lexical::*, syntax::*};
    use crate::{instruction::{ConstM1, ConstNil, ConstZero, F64ToI64, F64ToValue, I64ToValue, IfBranch}, ir::F64ToI64, mem::*};
    use e::I64;
    use failure::Fallible;
    use getset::Getters;
    use ghost_cell::{GhostCell, GhostToken};
    use jvm_core::MoveIntoObject;
    use jvm_core::TypeDeclaration;
    use runtime::code::{BlockBuilder, LinearRegisterPool, Register, VariableSet};
    use runtime::{code::Variable, instructions::bootstrap as b};
    use runtime_extra as e;
    use static_rc::StaticRc;
    use std::{cell::RefCell, collections::HashMap, mem::{replace, swap}, rc::Rc, slice::SliceIndex};
    use util::PooledStr;
    #[derive(Clone)]
    pub enum LuaRegister<'l> {
        Integer(Register<e::I64>),
        Float(Register<e::F64>),
        Function(Register<LuaValue>, LuaFunctionBuilderRef<'l>),
        Value(Register<LuaValue>, Option<()>),
    }
    impl<'l> LuaRegister<'l> {
        pub(crate) fn kind(&self) -> LuaRegisterKind {
            match self {
                LuaRegister::Integer(_) => LuaRegisterKind::Integer,
                LuaRegister::Float(_) => LuaRegisterKind::Float,
                LuaRegister::Function(_, _) | LuaRegister::Value(_, _) => LuaRegisterKind::Value,
            }
        }
    }
    #[derive(Clone, Copy)]
    pub enum LuaRegisterKind {
        Integer,
        Float,
        Value,
    }
    #[derive(Builder, Clone)]
    pub struct LuaExpr<'l> {
        register: LuaRegister<'l>,
        lifetime: ExprLifeTimeKind,
    }
    pub type LuaExprRef<'l> = Rc<LuaExpr<'l>>;
    pub enum LuaTableKey<'l> {
        Int(i64),
        String(String),
        Expr(LuaExprRef<'l>),
    }
    #[derive(PartialEq, Eq, Clone, Copy, Debug)]
    pub struct LuaTableMetadata {}
    pub enum ScoptKind<'l> {
        Loop { break_block: LuaBlockRef<'l> },
        Other,
    }
    #[derive(Clone, Copy, Debug)]
    pub enum ExprLifeTimeKind {
        Own,
        COW,
    }
    impl Default for ExprLifeTimeKind {
        fn default() -> Self { Self::Own }
    }
    #[derive(Default)]
    pub struct VarAttribute {
        is_const: bool,
        is_close: bool,
    }
    impl VarAttribute {
        pub fn new(name: String) -> Self {
            match &*name {
                "const" => VarAttribute {
                    is_const: true,
                    is_close: false,
                },
                "close" => VarAttribute {
                    is_const: false,
                    is_close: true,
                },
            }
        }
    }
    pub type LuaScoptRef<'l> = Rc<GhostCell<'l, LuaScopt<'l>>>;
    pub struct LuaScopt<'l> {
        variables: HashMap<String, LuaVariable<'l>>,
        kind: ScoptKind<'l>,
    }
    impl<'l> LuaScopt<'l> {
        pub fn new(kind: ScoptKind<'l>) -> Self {
            Self {
                variables: HashMap::new(),
                kind,
            }
        }
    }
    pub struct LuaVariable<'l> {
        expr: LuaExprRef<'l>,
        attributes: VarAttribute,
    }
    pub type LuaBlockRef<'l> = Rc<GhostCell<'l, LuaBlock<'l>>>;
    #[derive(Getters)]
    pub struct LuaBlock<'l> {
        #[getset(get = "pub")]
        builder: BlockBuilder<'l, LuaInstructionSet>,
    }
    impl<'l> LuaBlock<'l> {
        pub fn new() -> Self {
            Self {
                builder: BlockBuilder::default(),
            }
        }
    }
    pub type LuaFunctionBuilderRef<'l> = Rc<GhostCell<'l, LuaFunctionBuilder<'l>>>;
    pub enum LuaVar<'l> {
        Variable(String),
        Field(LuaExprRef<'l>, String),
        Element(LuaExprRef<'l>, LuaExprRef<'l>),
    }
    pub struct LuaFunctionBuilder<'l> {
        register_pool: LinearRegisterPool<{ <LuaValue as TypeDeclaration>::LAYOUT.size() }>,
        scopts: Vec<LuaScoptRef<'l>>,
        current_scopt: LuaScoptRef<'l>,
        blocks: Vec<LuaBlockRef<'l>>,
        current_block: LuaBlockRef<'l>,
        goto_blocks: HashMap<String, Vec<LuaBlockRef<'l>>>,
        label_blocks: HashMap<String, LuaBlockRef<'l>>,
        closure_variables: HashMap<(usize, String), usize>,
    }
    impl<'l> LuaFunctionBuilder<'l> {
        pub fn new() -> Self {
            let new_scopt = LuaScopt::new(ScoptKind::Other);
            let new_block = LuaBlock::new();
            let block = Rc::new(GhostCell::new(LuaBlock::new()));
            let new_scopt = Rc::new(GhostCell::new(new_scopt));
            let new_block = Rc::new(GhostCell::new(new_block));
            Self {
                register_pool: Default::default(),
                current_scopt: new_scopt,
                scopts: vec![new_scopt],
                current_block: new_block,
                blocks: vec![new_block],
                goto_blocks: Default::default(),
                label_blocks: Default::default(),
                closure_variables: Default::default(),
            }
        }
        pub fn new_block(&mut self) -> LuaBlockRef<'l> {
            let new_block = LuaBlock::new();
            let new_block_wraped = Rc::new(GhostCell::new(new_block));
            self.blocks.push(new_block_wraped.clone());
            new_block_wraped
        }
        pub fn new_scopt(&mut self, kind: ScoptKind<'l>) -> LuaScoptRef<'l> {
            let new_scopt = LuaScopt::new(kind);
            let new_scopt_wraped = Rc::new(GhostCell::new(new_scopt));
            self.scopts.push(new_scopt_wraped.clone());
            new_scopt_wraped
        }
    }
    macro_rules! unique_operate_type {
        ($ty:ty) => {
            impl FnOnce( &BlockBuilder<'_, LuaInstructionSet>, &mut GhostToken<'l>, &Register<$ty>,) -> Fallible<()>
        };
    }
    macro_rules! binary_operate_type {
        ($ty:ty) => {
            impl FnOnce( &BlockBuilder<'_, LuaInstructionSet>, &mut GhostToken<'l>, &Register<$ty>, &Register<$ty>,) -> Fallible<()>
        };
    }
    pub struct LuaContext<'l> {
        token: GhostToken<'l>,
        closure_stack: Vec<LuaFunctionBuilderRef<'l>>,
        current_function: LuaFunctionBuilderRef<'l>,
        current_scopt: LuaScoptRef<'l>,
        current_block: LuaBlockRef<'l>,
        current_builder: BlockBuilder<'l, LuaInstructionSet>,
    }
    impl<'l> LuaContext<'l> {
        pub fn new(token: GhostToken<'l>) -> Self {
            let new_function = LuaFunctionBuilder::new();
            let new_scopt = new_function.current_scopt.clone();
            let new_block = new_function.current_block.clone();
            let new_builder = new_block.borrow(&token).builder().clone();
            let new_function = Rc::new(GhostCell::new(new_function));
            Self {
                token,
                closure_stack: vec![new_function.clone()],
                current_function: new_function,
                current_scopt: new_scopt,
                current_block: new_block,
                current_builder: new_builder,
            }
        }
        pub fn new_function(&mut self) -> &LuaFunctionBuilderRef<'l> {
            let new_function = LuaFunctionBuilder::new();
            let new_scopt = new_function.current_scopt.clone();
            let new_block = new_function.current_block.clone();
            let new_function = Rc::new(GhostCell::new(new_function));
            self.closure_stack.push(new_function);
            self.current_function = new_function;
            self.current_scopt = new_scopt;
            self.current_block = new_block;
            self.current_builder = new_block.borrow(self.token()).builder.clone();
            &self.current_function
        }
        pub fn builder(&self) -> &mut BlockBuilder<'l, LuaInstructionSet> { &mut self.current_builder }
        pub fn token(&self) -> &GhostToken<'l> { &self.token }
        pub fn token_mut(&mut self) -> &mut GhostToken<'l> { &mut self.token }
        pub fn new_scopt(&mut self, kind: ScoptKind<'l>) -> &LuaScoptRef<'l> {
            let new_scopt = self.current_function_mut().new_scopt(kind);
            self.current_scopt = new_scopt;
            &self.current_scopt
        }
        pub fn new_block(&mut self) -> &LuaBlockRef<'l> {
            let new_block = self.current_function_mut().new_block();
            self.current_builder = new_block.borrow(self.token()).builder.clone();
            self.current_block = new_block;
            &self.current_block
        }
        pub fn current_function(&self) -> &LuaFunctionBuilder<'l> { self.current_function.borrow(self.token()) }
        pub fn current_function_mut(&self) -> &mut LuaFunctionBuilder<'l> {
            self.current_function.borrow_mut(self.token_mut())
        }
        pub fn current_block(&self) -> &LuaBlock<'l> { self.current_block.borrow(self.token()) }
        pub fn current_block_mut(&self) -> &mut LuaBlock<'l> { self.current_block.borrow_mut(self.token_mut()) }
        pub fn current_scopt(&self) -> &LuaScopt<'l> { self.current_scopt.borrow(self.token()) }
        pub fn current_scopt_mut(&self) -> &mut LuaScopt<'l> { self.current_scopt.borrow_mut(self.token_mut()) }
        pub fn phi(&mut self, from: &LuaBlockRef<'l>, to: &LuaBlockRef<'l>) -> Fallible<()> { todo!() }
        pub fn get_value(&mut self, name: String) -> Fallible<LuaExprRef<'l>> {
            for (closure_index, function) in self.closure_stack.iter().rev().enumerate() {
                for (scopt_index, scopt) in function.borrow(self.token()).scopts.iter().rev().enumerate() {
                    if let Some(variable) = scopt.borrow(self.token()).variables.get(&name) {
                        let expr = if closure_index == 0 {
                            variable.expr.clone()
                        } else {
                            let reg = self.alloc_register()?;
                            GetUpvalue::emit(self.builder(), self.token_mut(), &reg);
                            Rc::new(
                                LuaExprBuilder::default()
                                    .register(LuaRegister::Value(reg, None))
                                    .lifetime(ExprLifeTimeKind::COW)
                                    .build()?,
                            )
                        };
                        return Ok(Rc::new(
                            LuaExprBuilder::default()
                                .register(variable.expr.register.clone())
                                .lifetime(ExprLifeTimeKind::COW)
                                .build()?,
                        ));
                    }
                }
            }
            let reg = self.alloc_register()?;
            GetGlobal::emit(self.builder(), self.token_mut(), &name, &reg);
            Ok(Rc::new(
                LuaExprBuilder::default()
                    .register(LuaRegister::Value(reg, None))
                    .lifetime(ExprLifeTimeKind::COW)
                    .build()?,
            ))
        }
        pub fn put_value(&mut self, name: &String, value: LuaExprRef<'l>) -> Fallible<()> {
            for (closure_index, function) in self.closure_stack.iter().rev().enumerate() {
                for (scopt_index, scopt) in function.borrow(self.token()).scopts.iter().rev().enumerate() {
                    if let Some(variable) = scopt.borrow(self.token()).variables.get(&name) {
                        let expr = if closure_index == 0 {
                            self.move_expr(variable.expr.clone(), value)?;
                            variable.expr.clone()
                        } else {
                            let reg = self.alloc_register()?;
                            GetUpvalue::emit(self.builder(), self.token_mut(), &reg);
                            Rc::new(
                                LuaExprBuilder::default()
                                    .register(LuaRegister::Value(reg, None))
                                    .lifetime(ExprLifeTimeKind::COW)
                                    .build()?,
                            )
                        };
                    }
                }
            }
            let value = self.to_value(value)?;
            match &value.register {
                LuaRegister::Value(r, _) => {
                    SetGlobal::emit(self.builder(), self.token_mut(), &name, r);
                }
                _ => unreachable!(),
            }
            self.free_expr(value);
            Ok(())
        }
        pub fn branch(&mut self, from: &LuaBlockRef<'l>, to: &LuaBlockRef<'l>) -> Fallible<()> {
            self.phi(from, to)?;
            Goto::emit(
                from.borrow(self.token()).clone().builder(),
                self.token_mut(),
                to.borrow(self.token()).clone().builder(),
            )
        }
        pub fn branch_if(
            &mut self,
            predicate: LuaExprRef<'l>,
            from: &LuaBlockRef<'l>,
            t: &LuaBlockRef<'l>,
            f: &LuaBlockRef<'l>,
        ) -> Fallible<()> {
            self.phi(from, t)?;
            self.phi(from, f)?;
            match &predicate.register {
                LuaRegister::Integer(r) => Goto::emit(
                    from.borrow(self.token()).clone().builder(),
                    self.token_mut(),
                    t.borrow(self.token()).clone().builder(),
                )?,
                LuaRegister::Float(r) => Goto::emit(
                    from.borrow(self.token()).clone().builder(),
                    self.token_mut(),
                    t.borrow(self.token()).clone().builder(),
                )?,
                LuaRegister::Function(r, _) | LuaRegister::Value(r, _) => IfBranch::emit(
                    from.borrow(self.token()).clone().builder(),
                    self.token_mut(),
                    t.borrow(self.token()).clone().builder(),
                    f.borrow(self.token()).clone().builder(),
                    r,
                )?,
            };
            Ok(())
        }
        pub fn const_int(&mut self, int: i64) -> Fallible<LuaExprRef<'l>> {
            let reg = self.alloc_register()?;
            let const_value = match int {
                -1 => ConstM1::emit(self.builder(), self.token_mut(), &reg),
                0 => ConstZero::emit(self.builder(), self.token_mut(), &reg),
                1 => ConstOne::emit(self.builder(), self.token_mut(), &reg),
                o => ConstI64::emit(self.builder(), self.token_mut(), I64(int), &reg),
            };
            Ok(Rc::new(
                LuaExprBuilder::default().register(LuaRegister::Integer(reg)).build()?,
            ))
        }
        // [var_list(v),t!(=),expr_list(exprs)]=>cxt.put_values(v,exprs);
        pub fn put_values(&mut self, v: Vec<LuaVar<'l>>, expr: Vec<LuaExprRef<'l>>) -> Fallible<()> {
            let mut put_count = usize::min(v.len() - 1, expr.len() - 1);
            for (var, e) in v[0..put_count].iter().zip(expr[0..put_count].iter()) {
                let value = self.to_value(e.clone())?;
                match var {
                    LuaVar::Variable(var) => {
                        self.put_value(var, value)?;
                    }
                    LuaVar::Field(t, name) => {
                        let table = self.to_value(t.clone())?;
                        SetField::emit(self.builder(), self.token_mut())?;
                        self.free_expr(table)?;
                    }
                    LuaVar::Element(t, k) => {
                        let table = self.to_value(t.clone())?;
                        let key = self.to_value(k.clone())?;
                        SetElement::emit(self.builder(), self.token_mut(), &table, &key, &value)?;
                        self.free_expr(table)?;
                        self.free_expr(key)?;
                    }
                }
            }
            self.free_expr(value)?;
            Ok(())
        }
        // [function_call(c)]=>cxt.call(c);
        pub fn call(&mut self, c: LuaExprRef<'l>) -> Fallible<LuaExprRef<'l>> { todo!() }
        // [t!(break)]=>cxt.break_();
        pub fn break_(&mut self) -> Fallible<()> {
            let old_block = self.current_block.clone();
            let new_block = self.new_block();
            let function = self.current_function();
            let scopt = &function.current_scopt;
            for scopt in &function.scopts {
                match &scopt.borrow(self.token()).kind {
                    ScoptKind::Other => {}
                    ScoptKind::Loop { break_block } => {
                        self.branch(&old_block, &break_block)?;
                        return Ok(());
                    }
                }
            }
            Err(format_err!("invalid `break` statement"))
        }
        // [label(l)]=>cxt.define_label(l);
        pub fn define_label(&mut self, name: String) -> Fallible<()> {
            let function = self.current_function();
            let old_block = function.current_block.clone();
            let new_block = function.new_block();
            function
                .goto_blocks
                .entry(name)
                .or_insert_with(|| Default::default())
                .push(new_block);
            if let Some(goto_blocks_of_this_label) = function.goto_blocks.get(&name) {
                let goto_blocks_of_this_label = goto_blocks_of_this_label.clone();
                for goto_block in goto_blocks_of_this_label.iter() {
                    self.branch(&goto_block, &new_block)?;
                }
            }
            Ok(())
        }
        // [t!(goto),Name(n)]=>cxt.goto(n);
        pub fn goto(&mut self, name: String) -> Fallible<()> {
            let function = self.current_function().clone();
            let old_block = function.current_block.clone();
            let new_block = function.new_block();
            if let Some(label_block) = function.label_blocks.get(&name) {
                self.branch(&old_block, label_block)?;
            } else {
                function
                    .goto_blocks
                    .entry(name)
                    .or_insert_with(|| Default::default())
                    .push(old_block);
            }
            Ok(())
        }
        // [t!(do),block(b),t!(end)]=>cxt.finish(b);
        pub fn finish(&mut self, block: LuaBlockRef<'l>) -> Fallible<()> {
            self.new_block();
            Ok(())
        }
        // [t!(while),expr_wraped(e),t!(do),block(b),t!(end)]=>cxt.while_(e,b);
        pub fn while_(
            &mut self,
            predicate: ((LuaBlockRef<'l>, LuaBlockRef<'l>), LuaExprRef<'l>),
            loop_body: LuaBlockRef<'l>,
        ) -> Fallible<()> {
            let ((pre_block, predicate_block), predicate_expr) = predicate;
            self.branch_if(predicate_expr, &predicate_block, &loop_body, &self.current_block)?;
            self.branch(&loop_body, &predicate_block)?;
            self.branch(&pre_block, &predicate_block)?;
            Ok(())
        }
        // [t!(repeat),block(b),t!(until),expr_wraped(e)]=>ctx.repeat();
        pub fn repeat(
            &mut self,
            loop_body: LuaBlockRef<'l>,
            predicate: ((LuaBlockRef<'l>, LuaBlockRef<'l>), LuaExprRef<'l>),
        ) -> Fallible<()> {
            let ((pre_block, predicate_block), predicate_expr) = predicate;
            self.branch_if(predicate_expr, &predicate_block, &loop_body, &self.current_block)?;
            self.branch(&loop_body, &predicate_block)?;
            self.branch(&pre_block, &loop_body)?;
            Ok(())
        }
        // [if_prefix(p),t!(else),block(b),t!(end),block_split(b)]=>ctx.else_(p,a,b);
        pub fn else_(
            &mut self,
            if_prefix: (LuaBlockRef<'l>, LuaBlockRef<'l>),
            else_body: LuaBlockRef<'l>,
            post_block: (LuaBlockRef<'l>, LuaBlockRef<'l>),
        ) -> Fallible<()> {
            let post_block = post_block.1;
            let (true_block, false_block) = if_prefix;
            self.branch(&true_block, &post_block)?;
            self.branch(&false_block, &else_body)?;
            self.branch(&else_body, &post_block)?;
            Ok(())
        }
        // [if_prefix(p),t!(end),block_split(b)]=>ctx.end_if(p,b);
        pub fn end_if(
            &mut self,
            if_prefix: (LuaBlockRef<'l>, LuaBlockRef<'l>),
            post_block: (LuaBlockRef<'l>, LuaBlockRef<'l>),
        ) -> Fallible<()> {
            let post_block = post_block.1;
            let (true_block, false_block) = if_prefix;
            self.branch(&true_block, &post_block)?;
            self.branch(&false_block, &post_block)?;
            Ok(())
        }
        // [t!(for),Name(n),t!(=),expr(e),t!(,),block_split(p),expr(e1),t!(do),block(b),t!(end)]=>ctx.for_(n,e,e1,p,b);
        pub fn for_(
            &mut self,
            var: String,
            start: LuaExprRef<'l>,
            end: LuaExprRef<'l>,
            predicate: (LuaBlockRef<'l>, LuaBlockRef<'l>),
            loop_block: (LuaBlockRef<'l>, LuaBlockRef<'l>),
        ) -> Fallible<()> {
            let (pre_block, predicate_block) = predicate;
            let (loop_block, post_block) = loop_block;
            self.branch(&loop_block, &predicate_block)?;
            self.branch(&pre_block, &predicate_block)?;
            ForLoopJump::emit(start, end, &loop_block, &post_block);
            Ok(())
        }
        // [t!(for),Name(n),t!(=),expr(e),t!(,),expr(e1),t!(,),expr(e2),block_split(p),t!(do),block(b),t!(end)]=>ctx.for_step(n,e,e1,e2,p,b);
        pub fn for_step(
            &mut self,
            var: String,
            start: LuaExprRef<'l>,
            end: LuaExprRef<'l>,
            step: LuaExprRef<'l>,
            predicate: (LuaBlockRef<'l>, LuaBlockRef<'l>),
            loop_block: (LuaBlockRef<'l>, LuaBlockRef<'l>),
        ) -> Fallible<()> {
            let (pre_block, predicate_block) = predicate;
            let (loop_block, post_block) = loop_block;
            self.branch(&loop_block, &predicate_block)?;
            self.branch(&pre_block, &predicate_block)?;
            ForStepLoopJump::emit(start, end, step, &loop_block, &post_block);
            Ok(())
        }
        // [t!(for),name_list(n),t!(in),expr_list(e),block_split(p),t!(do),block(b),t!(end)]=>ctx.for_in(n,e,p,b);
        pub fn for_in(
            &mut self,
            var: String,
            exprs: Vec<LuaExprRef<'l>>,
            predicate: (LuaBlockRef<'l>, LuaBlockRef<'l>),
            loop_block: (LuaBlockRef<'l>, LuaBlockRef<'l>),
        ) -> Fallible<()> {
            let (pre_block, predicate_block) = predicate;
            let (loop_block, post_block) = loop_block;
            self.branch(&loop_block, &predicate_block)?;
            self.branch(&pre_block, &predicate_block)?;
            // ForInJump::emit(start, end, step, &loop_block, &post_block);
            Ok(())
        }
        // [t!(function),function_boby(f)]=>ctx.function(f);
        pub fn function(&mut self, body: LuaFunctionBuilderRef<'l>) -> Fallible<()> {
            let return_expr = self.alloc_register();
            NewClosure::emit(body, return_expr);
            Ok(())
        }
        // [t!(local),t!(function),Name(n),function_boby(f)]=>ctx.local_function(n,f);
        pub fn local_function(&mut self, name: String, body: LuaFunctionBuilderRef<'l>) -> Fallible<()> {
            let return_expr = self.variable_expr(&*name);
            NewClosure::emit(body, return_expr);
            Ok(())
        }
        pub fn load_var(&mut self, name: String) -> Fallible<LuaExprRef<'l>> { self.get_value(name) }
        pub fn add_local(&mut self, name: String, attr: VarAttribute, expr: LuaExprRef<'l>) -> Fallible<()> {
            self.current_scopt_mut()
                .variables
                .insert(name, LuaVariable { expr, attributes: attr });
            Ok(())
        }
        // [t!(local),att_name_list(a)]=>ctx.local_variable(a);
        pub fn local_variable(&mut self, names: Vec<(std::string::String, VarAttribute)>) -> Fallible<()> {
            for (name, attr) in names {
                let reg = self.alloc_register::<LuaValue>()?;
                ConstNil::emit(self.builder(), self.token_mut(), &reg)?;
                self.add_local(
                    name,
                    attr,
                    Rc::new(
                        LuaExprBuilder::default()
                            .register(LuaRegister::Value(reg, None))
                            .build()?,
                    ),
                )?;
            }
            Ok(())
        }
        // [t!(local),att_name_list(a),t!(=),expr_list(e)]=>ctx.local_variable_with_values(a,e);
        pub fn local_variable_with_values(
            &mut self,
            names: Vec<(std::string::String, VarAttribute)>,
            exprs: Vec<LuaExprRef<'l>>,
        ) -> Fallible<()> {
            for ((name, attr), expr) in names.into_iter().zip(exprs) {
                self.add_local(name, attr, expr)?;
            }
            Ok(())
        }
        pub fn trans_binary_type(
            use_integer: bool,
            use_float: bool,
            expr1: &LuaExprRef<'l>,
            expr2: &LuaExprRef<'l>,
        ) -> LuaRegisterKind {
            use LuaRegisterKind::*;
            if !use_integer && !use_float {
                Value
            } else {
                match (expr1.register.kind(), expr2.register.kind()) {
                    (Value, _) | (_, Value) => Value,
                    (Integer, Integer) => {
                        if use_integer {
                            Integer
                        } else {
                            Float
                        }
                    }
                    (Float, Float) | (Integer, Float) | (Float, Integer) => match (use_integer, use_float) {
                        (true, true) => Float,
                        (false, true) => Float,
                        (true, false) => Integer,
                        (false, false) => Value,
                    },
                }
            }
        }
        pub fn transport_register<F, T>(
            &mut self,
            register: &Register<F>,
            emit: impl FnOnce(
                &BlockBuilder<'l, LuaInstructionSet>,
                &mut GhostToken<'l>,
                &Register<F>,
                &Register<T>,
            ) -> Fallible<()>,
        ) -> Fallible<Register<T>> {
            let new_reg = self.alloc_register()?;
            emit(self.builder(), self.token_mut(), register, &new_reg)?;
            Ok(new_reg)
        }
        pub fn transform_expr(&mut self, expr: LuaExprRef<'l>, kind: LuaRegisterKind) -> Fallible<LuaExprRef<'l>> {
            let result = match (&expr.register, kind) {
                (LuaRegister::Integer(r), LuaRegisterKind::Integer) => return Ok(expr),
                (LuaRegister::Integer(r), LuaRegisterKind::Float) => {
                    LuaRegister::Float(self.transport_register(r, I64ToF64::emit)?)
                }
                (LuaRegister::Integer(r), LuaRegisterKind::Value) => {
                    LuaRegister::Value(self.transport_register(r, I64ToValue::emit)?, None)
                }
                (LuaRegister::Float(r), LuaRegisterKind::Integer) => {
                    LuaRegister::Integer(self.transport_register(r, F64ToI64::emit)?)
                }
                (LuaRegister::Float(r), LuaRegisterKind::Float) => return Ok(expr),
                (LuaRegister::Float(r), LuaRegisterKind::Value) => {
                    LuaRegister::Value(self.transport_register(r, F64ToValue::emit)?, None)
                }
                (LuaRegister::Function(r, _) | LuaRegister::Value(r, _), LuaRegisterKind::Value) => return Ok(expr),
                _ => unreachable!(),
            };
            Ok(Rc::new(LuaExprBuilder::default().register(result).build()?))
        }
        pub fn binary_operate(
            &mut self,
            expr1: LuaExprRef<'l>,
            expr2: LuaExprRef<'l>,
            emit_int: Option<binary_operate_type!(e::I64)>,
            emit_float: Option<binary_operate_type!(e::F64)>,
            emit_object: binary_operate_type!(LuaValue),
        ) -> Fallible<LuaExprRef<'l>> {
            let operate_kind = Self::trans_binary_type(emit_int.is_some(), emit_float.is_some(), &expr1, &expr2);
            let expr1 = Self::transform_expr(self, expr1, operate_kind)?;
            let expr2 = Self::transform_expr(self, expr2, operate_kind)?;
            let expr2 = self.to_writable(expr2)?;
            let result = match (&expr1.register, &expr2.register) {
                (LuaRegister::Integer(r1), LuaRegister::Integer(r2)) => {
                    (emit_int.unwrap())(self.builder(), self.token_mut(), r1, r2)?;
                    LuaRegister::Integer(r2.clone())
                }
                (LuaRegister::Float(r1), LuaRegister::Float(r2)) => {
                    (emit_float.unwrap())(self.builder(), self.token_mut(), r1, r2)?;
                    LuaRegister::Float(r2.clone())
                }
                (LuaRegister::Value(r1, _), LuaRegister::Value(r2, _)) => {
                    emit_object(self.builder(), self.token_mut(), r1, r2)?;
                    LuaRegister::Value(r2.clone(), None)
                }
                _ => unreachable!(),
            };
            self.free_expr(expr1);
            self.free_expr(expr2);
            Ok(Rc::new(LuaExprBuilder::default().register(result).build()?))
        }
        pub fn number_unique_operate(
            &mut self,
            expr1: LuaExprRef<'l>,
            emit_int: Option<unique_operate_type!(e::I64)>,
            emit_float: Option<unique_operate_type!(e::F64)>,
            emit_object: unique_operate_type!(LuaValue),
        ) -> Fallible<LuaExprRef<'l>> {
            let expr1 = self.to_writable(expr1)?;
            let builder = self.builder();
            let result = match &expr1.register {
                LuaRegister::Integer(r1) => {
                    (emit_int.unwrap())(builder, self.token_mut(), r1)?;
                    LuaRegister::Integer(*r1)
                }
                LuaRegister::Float(r1) => {
                    (emit_float.unwrap())(builder, self.token_mut(), r1)?;
                    LuaRegister::Float(*r1)
                }
                LuaRegister::Value(r1, s) => {
                    emit_object(builder, self.token_mut(), r1)?;
                    LuaRegister::Value(*r1, s.clone())
                }
                _ => unreachable!(),
            };
            self.free_expr(expr1);
            Ok(Rc::new(LuaExprBuilder::default().register(result).build()?))
        }
        pub fn emit_const_value(
            &mut self,
            expr1: LuaExprRef<'l>,
            emit_object: unique_operate_type!(LuaValue),
        ) -> Fallible<LuaExprRef<'l>> {
            let expr1 = self.to_writable(expr1)?;
            let builder = self.builder();
            let r1 = self.alloc_register()?;
            emit_object(builder, self.token_mut(), &r1)?;
            self.free_expr(expr1);
            Ok(Rc::new(
                LuaExprBuilder::default()
                    .register(LuaRegister::Value(r1, None))
                    .build()?,
            ))
        }
        fn to_value(&mut self, expr: LuaExprRef<'l>) -> Fallible<LuaExprRef<'l>> {
            Ok(match &expr.register {
                LuaRegister::Integer(r) => {
                    let new_reg = self.alloc_register()?;
                    I64ToValue::emit(self.builder(), self.token_mut(), &r, &new_reg)?;
                    self.free_expr(expr);
                    Rc::new(
                        LuaExprBuilder::default()
                            .register(LuaRegister::Value(new_reg, None))
                            .build()?,
                    )
                }
                LuaRegister::Float(r) => {
                    let new_reg = self.alloc_register()?;
                    F64ToValue::emit(self.builder(), self.token_mut(), &r, &new_reg)?;
                    self.free_expr(expr);
                    Rc::new(
                        LuaExprBuilder::default()
                            .register(LuaRegister::Value(new_reg, None))
                            .build()?,
                    )
                }
                _ => expr,
            })
        }
        fn to_writable(&mut self, expr: LuaExprRef<'l>) -> Fallible<LuaExprRef<'l>> {
            match &expr.lifetime {
                ExprLifeTimeKind::Own => Ok(expr),
                ExprLifeTimeKind::COW => {
                    if Rc::get_mut(&mut expr).is_some() {
                        Ok(expr)
                    } else {
                        let lua_register = match &expr.register {
                            LuaRegister::Integer(r) => {
                                let new_reg = self.alloc_register()?;
                                MoveI64::emit(self.builder(), self.token_mut(), r, &new_reg)?;
                                LuaRegister::Integer(new_reg)
                            }
                            LuaRegister::Float(r) => {
                                let new_reg = self.alloc_register()?;
                                MoveF64::emit(self.builder(), self.token_mut(), r, &new_reg)?;
                                LuaRegister::Float(new_reg)
                            }
                            LuaRegister::Function(r, s) => {
                                let new_reg = self.alloc_register()?;
                                MoveValue::emit(self.builder(), self.token_mut(), r, &new_reg)?;
                                LuaRegister::Function(new_reg, s.clone())
                            }
                            LuaRegister::Value(r, s) => {
                                let new_reg = self.alloc_register()?;
                                MoveValue::emit(self.builder(), self.token_mut(), r, &new_reg)?;
                                LuaRegister::Value(new_reg, s.clone())
                            }
                        };
                        Ok(Rc::new(LuaExprBuilder::default().register(lua_register).build()?))
                    }
                }
            }
        }
        fn alloc_register<T>(&mut self) -> Fallible<Register<T>> {
            self.current_function_mut()
                .register_pool
                .alloc()
                .ok_or_else(|| format_err!("not left register"))
        }
        fn free_expr(&mut self, expr_ref: LuaExprRef) -> Fallible<()> {
            let register_pool = &self.current_function_mut().register_pool;
            if let Ok(expr) = Rc::try_unwrap(expr_ref) {
                match expr.register {
                    LuaRegister::Integer(r) => register_pool.free(r),
                    LuaRegister::Float(r) => register_pool.free(r),
                    LuaRegister::Function(r, _) => register_pool.free(r),
                    LuaRegister::Value(r, _) => register_pool.free(r),
                }
            }
            Ok(())
        }
    }
}
/// Lua 5.4
/// https://www.lua.org/manual/5.4/
pub mod syntax {
    use super::builder::*;
    use crate::mem::LuaState;
    use failure::Fallible;
    use ghost_cell::GhostToken;
    use lexical_derive::token as t;
    use std::{collections::HashMap, rc::Rc};
    use syntax_derive::{lalr1_analyser, lr1_analyser, recursive_predictive_analysis};
    fn parse(vm: &mut LuaState) -> Fallible<LuaFunctionBuilderRef> {
        use super::{builder::*, ir::*};
        GhostToken::new(|token| {
            let mut ctx = vm.new_ctx(token)?;
            macro_rules! const_value {
                ($IntInstruction:ident) => {
                    ctx.emit_const_value($IntInstruction::emit)
                };
            }
            macro_rules! unique_integer_operate {
                ($IntInstruction:ident, $expr1:ident) => {
                    concat_idents::concat_idents!(
                        i_instruction = I,$IntInstruction {
                            ctx.unique_operate(
                                $expr1,
                                Some(i_instruction::emit),
                                None,
                                $IntInstruction::emit,
                    )})
                };
            }
            macro_rules! binary_integer_operate {
                ($IntInstruction:ident, $expr1:ident, $expr2:ident) => {
                    concat_idents::concat_idents!(
                        i_instruction = I,$IntInstruction {
                            ctx.binary_operate(
                                $expr1,
                                $expr2,
                                Some(i_instruction::emit),
                                None,
                                $IntInstruction::emit,
                    )})
                };
            }
            macro_rules! binary_float_operate {
                ($IntInstruction:ident, $expr1:ident, $expr2:ident) => {
                    concat_idents::concat_idents!(
                        f_instruction = F,$IntInstruction {
                            ctx.binary_operate(
                                $expr1,
                                $expr2,
                                None,
                                Some(f_instruction::emit),
                                $IntInstruction::emit,
                    )})
                };
            }
            macro_rules! binary_value_operate {
                ($IntIntruction:ident, $expr1:ident, $expr2:ident) => {
                    ctx.value_binary_operate($expr1, $expr2, $IntIntruction::emit)
                };
            }
            macro_rules! unique_value_operate {
                ($IntInstruction:ident, $expr1:ident) => {
                    ctx.value_unique_operate($expr1, $IntInstruction::emit)
                };
            }
            macro_rules! unique_operate {
                ($IntInstruction:ident, $expr1:ident) => {
                    ctx.unique_operate(
                        $expr1,
                        Some(<concat_idents!(I, $IntInstruction)>::emit),
                        Some(<concat_idents!(F, $IntInstruction)>::emit),
                        $IntInstruction::emit,
                    )
                };
            }
            macro_rules! binary_operate {
                ($IntInstruction:ident, $expr1:ident, $expr2:ident) => {
                    ctx.binary_operate(
                        $expr1,
                        $expr2,
                        Some(<concat_idents!(I, $IntInstruction)>::emit),
                        Some(<concat_idents!(F, $IntInstruction)>::emit),
                        $IntInstruction::emit,
                    )
                };
            }
            lalr1_analyser! {
              parser:LuaBlockRef->LuaExpr{
                chunk=>LuaBlockRef->{[block(b)]=>Ok(b);},
                block=>(LuaBlockRef<'_>,LuaBlockRef<'_>)->{
                  [scopt_begin(b),stat_list,return_expr(r),block_split(s)]=>ctx.return_(r,s);
                    | [scopt_begin(b),stat_list,block_split(s)]=>Ok(s);
                },
                stat_list->{ []|[stat_list,stat] },
                block_split=>(LuaBlockRef<'_>,LuaBlockRef<'_>)->{ []=>ctx.new_block(); },
                scopt_begin->{ []=>ctx.new_scopt(); },
                stat->{
                  [var_list(v),t!(=),expr_list(exprs)]=>ctx.put_values(v,exprs);
                  | [function_call(c)]=>Ok(());
                  | [t!(::),Name(n),t!(::)]=>ctx.define_label(n);
                  | [t!(break)]=>ctx.break_();
                  | [t!(goto),Name(n)]=>ctx.goto(n);
                  | [t!(do),block(b),t!(end)]=>ctx.finish(b);
                  | [t!(while),expr_wraped(e),t!(do),block(b),t!(end)]=>ctx.while_(e,b);
                  | [t!(repeat),block(b),t!(until),expr_wraped(e)]=>ctx.repeat(b,e);
                  | [if_prefix(p),t!(else),block(a),t!(end),block_split(b)]=>ctx.else_(p,a,b);
                  | [if_prefix(p),t!(end),block_split(b)]=>ctx.end_if(p,b);
                  | [t!(for),Name(n),t!(=),expr(e),t!(,),expr(e1),block_split(p),t!(do),block(b),t!(end)]=>ctx.for_(n,e,e1,p,b);
                  | [t!(for),Name(n),t!(=),expr(e),t!(,),expr(e1),t!(,),expr(e2),block_split(p),t!(do),block(b),t!(end)]=>ctx.for_step(n,e,e1,e2,p,b);
                  | [t!(for),name_list(n),t!(in),expr_list(e),block_split(p),t!(do),block(b),t!(end)]=>ctx.for_in(n,e,p,b);
                  | [t!(function),function_boby(f)]=>ctx.function(f);
                  | [t!(local),t!(function),Name(n),function_boby(f)]=>ctx.local_function(n,f);
                  | [t!(local),att_name_list(a)]=>ctx.local_variable(a);
                  | [t!(local),att_name_list(a),t!(=),expr_list(e)]=>ctx.local_variable_with_values(a,e);
                },
                expr_wraped=>((LuaBlockRef<'_>,LuaBlockRef<'_>),LuaExprRef)->{ [block_split(b),expr(e)]=>Ok((b,e)); },
                if_prefix=>(LuaBlockRef<'_>,LuaBlockRef<'_>)->{
                  [t!(if),expr(e),t!(then),block(b)]=>ctx.if_(e,b);
                    | [if_prefix(p),t!(elseif),expr(e),t!(then),block(b)]=>ctx.elseif(e,b);
                },
                att_name_list=>Vec<(std::string::String,VarAttribute)>->{
                  [Name(n),attrib(a)]=>Ok(vec![(n,a)]);
                  | [att_name_list(l),t!(,),Name(n),attrib(a)]=>Ok({l.push((n,a));l});
                },
                attrib=>VarAttribute->{
                  []=>Ok(Default::default());
                    | [t!(<),Name(n),t!(>)]=>Ok(VarAttribute::new(n));
                },
                return_expr=>Option<LuaExprRef>->{
                  [t!(return),option_semicolon]=>Ok(None);
                    | [t!(return),expr_list(e),option_semicolon]=>Ok(Some(e));
                },
                option_semicolon->{[]|[t!(;)]},
                function_name=>(Vec<std::string::String>,Option<std::string::String>)->{
                  [name_path(n)]=>Ok((n,None));
                    | [name_path(p),t!(:),Name(n)]=>Ok((p,Some(n)));
                },
                name_path=>Vec<std::string::String>->{
                  [Name(n)]=>Ok(vec![n]);
                    | [name_path(l),t!(.),Name(n)]=>Ok({l.push(n);l});
                },
                var_list=>Vec<LuaVar>->{
                  [var(v)]=>Ok(vec![v]);
                    | [var_list(l),t!(,),var(v)]=>Ok({l.push(v);l});
                },
                var=>LuaVar->{
                  [Name(n)]=>Ok(LuaVar::Variable(n));
                    | [prefix_expr(e),LeftBracket,expr(i),RightBracket]=>Ok(LuaVar::Element(e,i));
                      | [prefix_expr(e),t!(.),Name(n)]=>Ok(LuaVar::Field(e,n));
                },
                name_list=>Vec<LuaExprRef>->{
                  [Name(n)]=>Ok(vec![n]);
                    | [name_list(l),t!(,),Name(n)]=>Ok({l.push(n);n});
                },
                expr_list=>Vec<LuaExprRef>->{
                  [expr(e)]=>Ok(vec![e]);
                  | [expr_list(l),t!(,),expr(e)]=>Ok({l.push(e);e});
                },
                expr_high=>LuaExprRef->{
                  [expr1(e)]=>Ok(e); |[expr2(e)]=>Ok(e); |[expr3(e)]=>Ok(e);
                  |[expr4(e)]=>Ok(e); |[expr5(e)]=>Ok(e); |[expr6(e)]=>Ok(e);
                  |[expr7(e)]=>Ok(e); |[expr8(e)]=>Ok(e); |[expr9(e)]=>Ok(e);
                  |[expr10(e)]=>Ok(e); |[expr11(e)]=>Ok(e); |[expr12(e)]=>Ok(e);
                },
                expr_high_1=>LuaExprRef->{
                  [expr2(e)]=>Ok(e); |[expr3(e)]=>Ok(e); |[expr4(e)]=>Ok(e);
                      |[expr5(e)]=>Ok(e); |[expr6(e)]=>Ok(e); |[expr7(e)]=>Ok(e);
                      |[expr8(e)]=>Ok(e); |[expr9(e)]=>Ok(e); |[expr10(e)]=>Ok(e);
                      |[expr11(e)]=>Ok(e);
                  |[expr12(e)]=>Ok(e);
                      |[expr_highest(e)]=>Ok(e);
                },
                expr_high_2=>LuaExprRef->{
                  [expr3(e)]=>Ok(e); |[expr4(e)]=>Ok(e); |[expr5(e)]=>Ok(e);
                      |[expr6(e)]=>Ok(e); |[expr7(e)]=>Ok(e); |[expr8(e)]=>Ok(e);
                      |[expr9(e)]=>Ok(e); |[expr10(e)]=>Ok(e); |[expr11(e)]=>Ok(e);
                  | [expr12(e)]=>Ok(e); |[expr_highest(e)]=>Ok(e);
                },
                expr_high_3=>LuaExprRef->{
                  [expr4(e)]=>Ok(e); |[expr5(e)]=>Ok(e); |[expr6(e)]=>Ok(e);
                      |[expr7(e)]=>Ok(e); |[expr8(e)]=>Ok(e); |[expr9(e)]=>Ok(e);
                      |[expr10(e)]=>Ok(e); |[expr11(e)]=>Ok(e); | [expr12(e)]=>Ok(e);
                      |[expr_highest(e)]=>Ok(e);
                },
                expr_high_4=>LuaExprRef->{
                  [expr5(e)]=>Ok(e); |[expr6(e)]=>Ok(e); |[expr7(e)]=>Ok(e);
                      |[expr8(e)]=>Ok(e); |[expr9(e)]=>Ok(e); |[expr10(e)]=>Ok(e);
                      |[expr11(e)]=>Ok(e); | [expr12(e)]=>Ok(e); |[expr_highest(e)]=>Ok(e);
                },
                expr_high_5=>LuaExprRef->{
                  [expr6(e)]=>Ok(e); |[expr7(e)]=>Ok(e); |[expr8(e)]=>Ok(e);
                      |[expr9(e)]=>Ok(e); |[expr10(e)]=>Ok(e); |[expr11(e)]=>Ok(e);
                  | [expr12(e)]=>Ok(e); |[expr_highest(e)]=>Ok(e);
                },
                expr_high_6=>LuaExprRef->{
                  [expr7(e)]=>Ok(e); |[expr8(e)]=>Ok(e); |[expr9(e)]=>Ok(e);
                      |[expr10(e)]=>Ok(e); |[expr11(e)]=>Ok(e); | [expr12(e)]=>Ok(e);
                      |[expr_highest(e)]=>Ok(e);
                },
                expr_high_7=>LuaExprRef->{
                  [expr8(e)]=>Ok(e); |[expr9(e)]=>Ok(e); |[expr10(e)]=>Ok(e);
                      |[expr11(e)]=>Ok(e); | [expr12(e)]=>Ok(e); |[expr_highest(e)]=>Ok(e);
                },
                expr_high_8=>LuaExprRef->{
                  [expr9(e)]=>Ok(e); |[expr10(e)]=>Ok(e); |[expr11(e)]=>Ok(e);
                  | [expr12(e)]=>Ok(e); |[expr_highest(e)]=>Ok(e);
                },
                expr_high_9=>LuaExprRef->{
                  [expr10(e)]=>Ok(e); |[expr11(e)]=>Ok(e); | [expr12(e)]=>Ok(e);
                      |[expr_highest(e)]=>Ok(e);
                },
                expr_high_10=>LuaExprRef->{
                  [expr11(e)]=>Ok(e); | [expr12(e)]=>Ok(e); |[expr_highest(e)]=>Ok(e);
                },
                expr_high_11=>LuaExprRef->{ [expr12(e)]=>Ok(e); |[expr_highest(e)]=>Ok(e); },
                expr1=>LuaExprRef->{ [expr_high_1(v),t!(or),block_split(b1),expr_high_2(v1),block_split(b2)]=>ctx.or(v,b1,v1,2); },
                expr2=>LuaExprRef->{ [expr_high_2(v),t!(and),block_split(b1),expr_high_2(v1),block_split(b2)]=>ctx.and(v,b1,v1,b2); },
                expr3=>LuaExprRef->{
                  [expr_high_3(v),t!(<),expr_high_3(v1)]=>binary_operate!(Less,v,v1);
                  |[expr_high_3(v),t!(>),expr_high_3(v1)]=>binary_operate!(Large,v,v1);
                  |[expr_high_3(v),t!(<=),expr_high_3(v1)]=>binary_operate!(LessOrEqual,v,v1);
                  |[expr_high_3(v),t!(>=),expr_high_3(v1)]=>binary_operate!(LargeOrEqual,v,v1);
                  |[expr_high_3(v),NotEqual,expr_high_3(v1)]=>binary_operate!(NotEqual,v,v1);
                  |[expr_high_3(v),t!(==),expr_high_3(v1)]=>binary_operate!(Equal,v,v1);
                },
                expr4=>LuaExprRef->{ [expr_high_4(v),t!(|),expr_high_4(v1)]=>binary_integer_operate!(BitOr,v,v1); },
                expr5=>LuaExprRef->{ [expr_high_5(v),t!(~),expr_high_5(v1)]=>binary_integer_operate!(BitXor,v,v1); },
                expr6=>LuaExprRef->{ [expr_high_6(v),t!(&),expr_high_6(v1)]=>binary_integer_operate!(BitAnd,v,v1); },
                expr7=>LuaExprRef->{
                  [expr_high_7(v),t!(<<),expr_high_7(v1)]=>binary_integer_operate!(LeftShift,v,v1);
                  | [expr_high_7(v),t!(>>),expr_high_7(v1)]=>binary_integer_operate!(RightShift,v,v1);
                },
                expr8=>LuaExprRef->{ [expr_high_8(v),t!(..),expr_high_8(v1)]=>binary_value_operate!(Concat,v,v1); },
                expr9=>LuaExprRef->{
                  [expr_high_9(v),t!(+),expr_high_9(v1)]=>binary_operate!(Add,v,v1);
                  | [expr_high_9(v),t!(-),expr_high_9(v1)]=>binary_operate!(Sub,v,v1);
                },
                expr10=>LuaExprRef->{
                  [expr_high_10(v),t!(*),expr_high_10(v1)]=>binary_operate!(Mul,v,v1);
                  |[expr_high_10(v),t!(/),expr_high_10(v1)]=>binary_operate!(Div,v,v1);
                  |[expr_high_10(v),DoubleSlash,expr_high_10(v1)]=>binary_operate!(DivFloor,v,v1);
                  |[expr_high_10(v),t!(%),expr_high_10(v1)]=>binary_operate!(Rem,v,v1);
                },
                expr11=>LuaExprRef->{
                  [t!(not),expr_high_11(v)]=>unique_integer_operate!(Not,v);
                  |[t!(#),expr_high_11(v)]=>unique_value_operate!(Len,v);
                  |[t!(-),expr_high_11(v)]=>unique_operate!(Neg,v);
                  |[t!(~),expr_high_11(v)]=>unique_integer_operate!(BitNot,v);
                },
                expr12=>LuaExprRef->{
                  [expr_highest(v),t!(^),expr_highest(v1)]=>binary_float_operate!(Pow,v,v1);
                },
                expr=>LuaExprRef->{
                  [t!(nil)]=>const_value!(ConstNil);
                    | [t!(false)]=>const_value!(ConstFalse);
                      | [t!(true)]=>const_value!(ConstTrue);
                      | [Number(n)]
                      | [String(s)]
                      | [t!(...)]
                      | [function_def(f)]
                      | [prefix_expr(p)]
                      | [function_call(c)]
                      | [table_constructor(t)]
                      | [expr_high(e)]
                },
                expr_highest=>LuaExprRef->{
                  [t!(nil)]=>const_value!(ConstNil);
                    | [t!(false)]=>const_value!(ConstFalse);
                      | [t!(true)]=>const_value!(ConstTrue);
                      | [Number(n)]
                      | [String(s)]
                      | [t!(...)]
                      | [function_def(f)]
                      | [prefix_expr(p)]
                      | [function_call(c)]
                      | [table_constructor(t)]
                },
                prefix_expr=>LuaExprRef->{
                  [var(v)]=>Ok(v);
                    | [function_call(f)]=>Ok(f);
                      | [LeftParen,expr(e),RightParen]=>Ok(e);
                },
                function_call=>LuaExprRef->{
                  [prefix_expr(e),args(a)]=>ctx.call(e,a);
                    | [prefix_expr(e),t!(:),Name(n),args(a)]=>ctx.call_self(e,n,a);
                },
                args->{
                  [LeftParen,expr_list(e),RightParen]=>ctx.arg_list(e);
                    | [table_constructor(t)]=>ctx.table_constructor(t);
                      | [String(s)]=>ctx.string(s);
                },
                function_def=>LuaFunctionBuilderRef->{[t!(function),function_boby(f)]=>Ok(f);},
                function_boby=>LuaFunctionBuilderRef->{[LeftParen,param_list(p),RightParen,block(b),t!(end)]=>ctx.finish_function(p,b);},
                param_list=>(Vec<String>,bool)->{
                  [t!(...)]=>Ok((vec![],false));
                    | [name_list(n)]=>Ok((n,false));
                      | [name_list(n),t!(,),t!(...)]=>Ok((n,true));
                },
                table_constructor=>Vec<(LuaTableKey,LuaExprRef)>->{[LeftBrace,field_list(f),RgithBrace]=>Ok(f);},
                field_list=>Vec<(LuaTableKey,LuaExprRef)>->{
                  [field(f)]=>Ok(vec![f]);
                    | [field(f),field_sep]=>Ok(vec![f]);
                      | [field_list(l),field_sep,field(f)]=>Ok({l.push(f);l});
                      | [field_list(l),field_sep,field(f),field_sep]=>Ok({l.push(f);l});
                },
                field_sep->{[t!(,)]|[t!(;)]},
                field=>(LuaTableKey,LuaExprRef)->{
                  [LeftBracket,expr(e),RightBracket,expr(v)]=>Ok((LuaTableKey::Expr(e),v));
                    | [Name(n),t!(=),expr(v)]=>Ok((LuaTableKey::String(n),v));
                      | [expr(e)]=>Ok((LuaTableKey::None,e));
                }
              }
            }
        });
        todo!();
    }
}
